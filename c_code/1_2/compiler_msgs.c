/* Generated by Nim Compiler v0.11.2 */
/*   (c) 2015 Andreas Rumpf */
/* The generated code is subject to the original license. */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>

#include <setjmp.h>

#include <stdio.h>

#include <stdlib.h>
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct Table165376 Table165376;
typedef struct Keyvaluepairseq165379 Keyvaluepairseq165379;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct TY165415 TY165415;
typedef struct Tfileinfo165336 Tfileinfo165336;
typedef struct Ropeobj163009 Ropeobj163009;
typedef struct TY163599 TY163599;
typedef struct Tcell46746 Tcell46746;
typedef struct Tcellseq46762 Tcellseq46762;
typedef struct Tgcheap48616 Tgcheap48616;
typedef struct Tcellset46758 Tcellset46758;
typedef struct Tpagedesc46754 Tpagedesc46754;
typedef struct Tmemregion28610 Tmemregion28610;
typedef struct Tsmallchunk27840 Tsmallchunk27840;
typedef struct Tllchunk28604 Tllchunk28604;
typedef struct Tbigchunk27842 Tbigchunk27842;
typedef struct Tintset27817 Tintset27817;
typedef struct Ttrunk27813 Ttrunk27813;
typedef struct Tavlnode28608 Tavlnode28608;
typedef struct Tgcstat48614 Tgcstat48614;
typedef struct Keyvaluepair165382 Keyvaluepair165382;
typedef struct Exception Exception;
typedef struct TNimObject TNimObject;
typedef struct TSafePoint TSafePoint;
typedef struct Tlineinfo165338 Tlineinfo165338;
typedef struct Erecoverableerror165344 Erecoverableerror165344;
typedef struct Valueerror3449 Valueerror3449;
typedef struct TY166033 TY166033;
typedef struct Esuggestdone165346 Esuggestdone165346;
typedef struct Slice167076 Slice167076;
typedef struct TY149210 TY149210;
typedef struct Tbasechunk27838 Tbasechunk27838;
typedef struct Tfreecell27830 Tfreecell27830;
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
typedef NimStringDesc* TY165288[278];
typedef NimStringDesc* TY165297[31];
typedef NimStringDesc* TY165302[17];
struct  Table165376  {
Keyvaluepairseq165379* data;
NI counter;
};
typedef N_NIMCALL_PTR(void, TY3289) (void* p, NI op);
typedef N_NIMCALL_PTR(void*, TY3294) (void* p);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY3289 marker;
TY3294 deepcopy;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct  Tfileinfo165336  {
NimStringDesc* fullpath;
NimStringDesc* projpath;
NimStringDesc* shortname;
Ropeobj163009* quotedname;
TY163599* lines;
NimStringDesc* dirtyfile;
};
struct  Tcell46746  {
NI refcount;
TNimType* typ;
};
struct  Tcellseq46762  {
NI len;
NI cap;
Tcell46746** d;
};
struct  Tcellset46758  {
NI counter;
NI max;
Tpagedesc46754* head;
Tpagedesc46754** data;
};
typedef Tsmallchunk27840* TY28622[512];
typedef Ttrunk27813* Ttrunkbuckets27815[256];
struct  Tintset27817  {
Ttrunkbuckets27815 data;
};
struct  Tmemregion28610  {
NI minlargeobj;
NI maxlargeobj;
TY28622 freesmallchunks;
Tllchunk28604* llmem;
NI currmem;
NI maxmem;
NI freemem;
NI lastsize;
Tbigchunk27842* freechunkslist;
Tintset27817 chunkstarts;
Tavlnode28608* root;
Tavlnode28608* deleted;
Tavlnode28608* last;
Tavlnode28608* freeavlnodes;
};
struct  Tgcstat48614  {
NI stackscans;
NI cyclecollections;
NI maxthreshold;
NI maxstacksize;
NI maxstackcells;
NI cycletablesize;
NI64 maxpause;
};
struct  Tgcheap48616  {
void* stackbottom;
NI cyclethreshold;
Tcellseq46762 zct;
Tcellseq46762 decstack;
Tcellset46758 cycleroots;
Tcellseq46762 tempstack;
NI recgclock;
Tmemregion28610 region;
Tgcstat48614 stat;
};
struct Keyvaluepair165382 {
NI Field0;
NimStringDesc* Field1;
NI32 Field2;
};
struct  TNimObject  {
TNimType* m_type;
};
struct  Exception  {
  TNimObject Sup;
Exception* parent;
NCSTRING name;
NimStringDesc* message;
NimStringDesc* trace;
};
typedef struct {
N_NIMCALL_PTR(NIM_BOOL, ClPrc) (Exception* e, void* ClEnv);
void* ClEnv;
} TY15609;
struct  TSafePoint  {
TSafePoint* prev;
NI status;
jmp_buf context;
NIM_BOOL hasRaiseAction;
TY15609 raiseAction;
};
struct  Tlineinfo165338  {
NI16 line;
NI16 col;
NI32 fileindex;
};
struct  Valueerror3449  {
  Exception Sup;
};
struct  Erecoverableerror165344  {
  Valueerror3449 Sup;
};
typedef struct {
N_NIMCALL_PTR(void, ClPrc) (NimStringDesc* output, void* ClEnv);
void* ClEnv;
} TY166054;
typedef NimStringDesc* TY157201[1];
typedef N_CLOSURE_PTR(void, TMP1195) (NimStringDesc* output);
struct  Esuggestdone165346  {
  Exception Sup;
};
typedef N_CLOSURE_PTR(void, TMP1206) (NimStringDesc* output);
typedef NimStringDesc* TY166825[4];
struct  Slice167076  {
NU16 a;
NU16 b;
};
struct TY149210 {
NimStringDesc* Field0;
NI Field1;
};
typedef struct {
N_NIMCALL_PTR(void, ClPrc) (NU8 err, NimStringDesc* msg, NIM_BOOL usewarning, void* ClEnv);
void* ClEnv;
} TY163023;
typedef N_CLOSURE_PTR(void, TMP1265) (NU8 err, NimStringDesc* msg, NIM_BOOL usewarning, void* ClEnv);
struct  Ropeobj163009  {
  TNimObject Sup;
Ropeobj163009* left;
Ropeobj163009* right;
NI length;
NimStringDesc* data;
};
typedef NI TY27820[8];
struct  Tpagedesc46754  {
Tpagedesc46754* next;
NI key;
TY27820 bits;
};
struct  Tbasechunk27838  {
NI prevsize;
NI size;
NIM_BOOL used;
};
struct  Tsmallchunk27840  {
  Tbasechunk27838 Sup;
Tsmallchunk27840* next;
Tsmallchunk27840* prev;
Tfreecell27830* freelist;
NI free;
NI acc;
NF data;
};
struct  Tllchunk28604  {
NI size;
NI acc;
Tllchunk28604* next;
};
struct  Tbigchunk27842  {
  Tbasechunk27838 Sup;
Tbigchunk27842* next;
Tbigchunk27842* prev;
NI align;
NF data;
};
struct  Ttrunk27813  {
Ttrunk27813* next;
NI key;
TY27820 bits;
};
typedef Tavlnode28608* TY28614[2];
struct  Tavlnode28608  {
TY28614 link;
NI key;
NI upperbound;
NI level;
};
struct  Tfreecell27830  {
Tfreecell27830* next;
NI zerofield;
};
struct TY165415 {
  TGenericSeq Sup;
  Tfileinfo165336 data[SEQ_DECL_SIZE];
};
struct TY163599 {
  TGenericSeq Sup;
  Ropeobj163009* data[SEQ_DECL_SIZE];
};
struct TY166033 {
  TGenericSeq Sup;
  Tlineinfo165338 data[SEQ_DECL_SIZE];
};
struct Keyvaluepairseq165379 {
  TGenericSeq Sup;
  Keyvaluepair165382 data[SEQ_DECL_SIZE];
};
N_NIMCALL(void, inittable_165368)(NI initialsize, Table165376* Result);
N_NOINLINE(void, chckNil)(void* p);
N_NIMCALL(void, genericReset)(void* dest, TNimType* mt);
N_NIMCALL(void, nimGCvisit)(void* d, NI op);
N_NIMCALL(void, TMP1166)(void* p, NI op);
static N_INLINE(void, nimGCunrefNoCycle)(void* p);
static N_INLINE(Tcell46746*, usrtocell_50246)(void* usr);
static N_INLINE(void, nimFrame)(TFrame* s);
N_NOINLINE(void, stackoverflow_20001)(void);
static N_INLINE(void, popFrame)(void);
static N_INLINE(void, rtladdzct_51804)(Tcell46746* c);
N_NOINLINE(void, addzct_50217)(Tcellseq46762* s, Tcell46746* c);
N_NIMCALL(void*, newSeqRC1)(TNimType* typ, NI len);
N_NIMCALL(NimStringDesc*, tocchar_165439)(NIM_CHAR c);
static N_INLINE(void, appendChar)(NimStringDesc* dest, NIM_CHAR c);
N_NIMCALL(NimStringDesc*, nsuToOctal)(NIM_CHAR c);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
N_NIMCALL(NimStringDesc*, rawNewString)(NI space);
N_NIMCALL(NimStringDesc*, nimCharToStr)(NIM_CHAR x);
N_NIMCALL(Ropeobj163009*, makecstring_165449)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, rawNewString)(NI cap);
static N_INLINE(NI, addInt)(NI a, NI b);
N_NOINLINE(void, raiseOverflow)(void);
static N_INLINE(NI, chckRange)(NI i, NI a, NI b);
N_NOINLINE(void, raiseRangeError)(NI64 val);
N_NIMCALL(NimStringDesc*, resizeString)(NimStringDesc* dest, NI addlen);
static N_INLINE(NI, subInt)(NI a, NI b);
static N_INLINE(NI, modInt)(NI a, NI b);
N_NOINLINE(void, raiseDivByZero)(void);
N_NIMCALL(NimStringDesc*, addChar)(NimStringDesc* s, NIM_CHAR c);
N_NOINLINE(void, raiseIndexError)(void);
N_NIMCALL(void, add_163534)(Ropeobj163009** a, Ropeobj163009* b);
N_NIMCALL(Ropeobj163009*, rope_163320)(NimStringDesc* s);
N_NIMCALL(void, newfileinfo_165495)(NimStringDesc* fullpath, NimStringDesc* projpath, Tfileinfo165336* Result);
N_NIMCALL(void, unsureAsgnRef)(void** dest, void* src);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(NimStringDesc*, nosextractFilename)(NimStringDesc* path);
N_NIMCALL(NimStringDesc*, noschangeFileExt)(NimStringDesc* filename, NimStringDesc* ext);
N_NIMCALL(void*, newSeq)(TNimType* typ, NI len);
N_NIMCALL(NIM_BOOL, haskey_165543)(Table165376 t, NimStringDesc* key);
static N_INLINE(NI, rawget_165555)(Table165376 t, NimStringDesc* key, NI* hc);
N_NIMCALL(NI, hash_134839)(NimStringDesc* x);
static N_INLINE(NIM_BOOL, isfilled_158211)(NI hcode);
static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b);
static N_INLINE(NI, nexttry_158420)(NI h, NI maxhash);
N_NIMCALL(NI32, HEX5BHEX5D_165586)(Table165376 t, NimStringDesc* key);
N_NIMCALL(void, HEX5BHEX5DHEX3D_165635)(Table165376* t, NimStringDesc* key, NI32 val);
N_NIMCALL(void, enlarge_165672)(Table165376* t);
static N_INLINE(NI, rawgetknownhc_165726)(Table165376 t, NimStringDesc* key, NI hc);
N_NIMCALL(void, rawinsert_165752)(Table165376* t, Keyvaluepairseq165379** data, NimStringDesc* key, NI32 val, NI hc, NI h);
N_NIMCALL(NI32, fileinfoidx_165533)(NimStringDesc* filename, NIM_BOOL* isknownfile);
static N_INLINE(void, pushSafePoint)(TSafePoint* s);
N_NIMCALL(NimStringDesc*, canonicalizepath_156374)(NimStringDesc* path);
static N_INLINE(void, shallow_89424)(NimStringDesc** s_89427);
static N_INLINE(void, popSafePoint)(void);
static N_INLINE(void, setFrame)(TFrame* s);
static N_INLINE(void, popCurrentException)(void);
static N_INLINE(void, asgnRef)(void** dest, void* src);
static N_INLINE(void, incref_52622)(Tcell46746* c);
static N_INLINE(NIM_BOOL, canbecycleroot_50267)(Tcell46746* c);
static N_INLINE(void, rtladdcycleroot_51023)(Tcell46746* c);
N_NOINLINE(void, incl_47465)(Tcellset46758* s, Tcell46746* cell);
static N_INLINE(void, decref_52204)(Tcell46746* c);
N_NIMCALL(void, reraiseException)(void);
N_NIMCALL(NimStringDesc*, shortendir_156407)(NimStringDesc* dir);
N_NIMCALL(TGenericSeq*, incrSeq)(TGenericSeq* seq, NI elemsize);
N_NIMCALL(void, genericAssign)(void* dest, void* src, TNimType* mt);
N_NIMCALL(NI32, fileinfoidx_165853)(NimStringDesc* filename);
N_NIMCALL(Tlineinfo165338, newlineinfo_165866)(NI32 fileinfoidx, NI line, NI col);
static N_INLINE(Tlineinfo165338, newlineinfo_165878)(NimStringDesc* filename, NI line, NI col);
N_NOINLINE(void, raiserecoverableerror_165966)(NimStringDesc* msg);
N_NIMCALL(void, TMP1191)(void* p, NI op);
N_NIMCALL(void*, newObj)(TNimType* typ, NI size);
N_NIMCALL(NimStringDesc*, copyStringRC1)(NimStringDesc* src);
N_NIMCALL(void, raiseException)(Exception* e, NCSTRING ename);
N_NIMCALL(Tlineinfo165338, unknownlineinfo_166024)(void);
N_NIMCALL(void, TMP1193)(void* p, NI op);
N_NIMCALL(void, suggestwriteln_166066)(NimStringDesc* s);
static N_INLINE(void, writeln_157205)(FILE* f, NimStringDesc** x, NI xLen0);
N_NIMCALL(void, write_13457)(FILE* f, NimStringDesc* s);
N_NIMCALL(void, msgquit_166104)(NI8 x);
N_NIMCALL(void, msgquit_166113)(NimStringDesc* x);
N_NIMCALL(void, quit_87981)(NimStringDesc* errormsg, NI errorcode);
N_NIMCALL(void, suggestquit_166122)(void);
N_NIMCALL(void, TMP1196)(void* p, NI op);
N_NIMCALL(NI, getinfocontextlen_166153)(void);
N_NIMCALL(void, setinfocontextlen_166170)(NI L);
N_NIMCALL(TGenericSeq*, setLengthSeq)(TGenericSeq* seq, NI elemsize, NI newlen);
N_NIMCALL(void, pushinfocontext_166189)(Tlineinfo165338 info);
N_NIMCALL(void, popinfocontext_166208)(void);
N_NIMCALL(Tlineinfo165338, getinfocontext_166234)(NI index);
N_NIMCALL(NimStringDesc*, tofilename_166263)(NI32 fileidx);
N_NIMCALL(NimStringDesc*, tofullpath_166273)(NI32 fileidx);
N_NIMCALL(void, setdirtyfile_166283)(NI32 fileidx, NimStringDesc* filename);
N_NIMCALL(void, failedassertimpl_88817)(NimStringDesc* msg);
N_NIMCALL(NimStringDesc*, tofullpathconsiderdirty_166407)(NI32 fileidx);
N_NIMCALL(NimStringDesc*, tomsgfilename_166429)(Tlineinfo165338 info);
static N_INLINE(NI, tolinenumber_166439)(Tlineinfo165338 info);
static N_INLINE(NI, tocolumn_166449)(Tlineinfo165338 info);
static N_INLINE(NimStringDesc*, tofileline_166459)(Tlineinfo165338 info);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI x);
static N_INLINE(NimStringDesc*, tofilelinecol_166469)(Tlineinfo165338 info);
N_NIMCALL(NimStringDesc*, HEX24_166479)(Tlineinfo165338 info);
N_NIMCALL(NIM_BOOL, HEX3FHEX3F_166489)(Tlineinfo165338 info, NimStringDesc* filename);
N_NIMCALL(NIM_BOOL, contains_101362)(NimStringDesc* s, NimStringDesc* sub);
N_NIMCALL(void, outwriteln_166505)(NimStringDesc* s);
N_NIMCALL(void, msgwriteln_166536)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, coordtostr_166606)(NI coord);
N_NIMCALL(NimStringDesc*, msgkindtostring_166616)(NU16 kind);
N_NIMCALL(NimStringDesc*, getmessagestr_166626)(NU16 msg, NimStringDesc* arg);
N_NIMCALL(NimStringDesc*, nsuFormatOpenArray)(NimStringDesc* formatstr, NimStringDesc** a, NI aLen0);
N_NIMCALL(void, handleerror_166647)(NU16 msg, NU8 eh, NimStringDesc* s);
N_NIMCALL(NIM_BOOL, stacktraceavailable_17930)(void);
N_NIMCALL(void, writestacktrace_16407)(void);
N_NIMCALL(NIM_BOOL, HEX3DHEX3D_166789)(Tlineinfo165338 a, Tlineinfo165338 b);
N_NIMCALL(void, writecontext_166800)(Tlineinfo165338 lastinfo);
N_NIMCALL(NIM_BOOL, ignoremsgbecauseofidetools_166850)(NU16 msg);
N_NIMCALL(void, rawmessage_166888)(NU16 msg, NimStringDesc** args, NI argsLen0);
N_NIMCALL(NimStringDesc*, nsuFormatSingleElem)(NimStringDesc* formatstr, NimStringDesc* a);
N_NIMCALL(void, rawmessage_166960)(NU16 msg, NimStringDesc* arg);
N_NIMCALL(void, writesurroundingsrc_166972)(Tlineinfo165338 info);
N_NIMCALL(NimStringDesc*, HEX24_164131)(Ropeobj163009* r);
N_NIMCALL(NimStringDesc*, nsuRepeatChar)(NIM_CHAR c, NI count);
N_NIMCALL(NimStringDesc*, formatmsg_166982)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg);
static N_INLINE(NIM_BOOL, contains_167086)(Slice167076 s, NU16 value);
N_NIMCALL(void, limessage_166997)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg, NU8 eh);
static N_INLINE(Slice167076, HEX2EHEX2E_167067)(NU16 a, NU16 b);
N_NIMCALL(void, fatal_167123)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg);
N_NIMCALL(void, globalerror_167134)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg);
N_NIMCALL(void, globalerror_167145)(Tlineinfo165338 info, NimStringDesc* arg);
N_NIMCALL(void, localerror_167155)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg);
N_NIMCALL(void, localerror_167166)(Tlineinfo165338 info, NimStringDesc* arg);
N_NIMCALL(void, localerror_167176)(Tlineinfo165338 info, NimStringDesc* format, NimStringDesc** params, NI paramsLen0);
N_NIMCALL(void, message_167188)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg);
N_NIMCALL(void, internalerror_167199)(Tlineinfo165338 info, NimStringDesc* errmsg);
N_NIMCALL(void, internalerror_167218)(NimStringDesc* errmsg);
N_NIMCALL(void, addsourceline_167254)(NI32 fileidx, NimStringDesc* line);
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src);
N_NIMCALL(NimStringDesc*, HEX24_167306)(TY149210 x);
N_NIMCALL(Ropeobj163009*, sourceline_165988)(Tlineinfo165338 i);
N_NIMCALL(FILE*, open_13217)(NimStringDesc* filename, NU8 mode, NI bufsize);
N_NIMCALL(NIM_BOOL, readline_13481)(FILE* f, NimStringDesc** line);
N_NIMCALL(NIM_BOOL, isObj)(TNimType* obj, TNimType* subclass);
static N_INLINE(Exception*, getCurrentException)(void);
N_NIMCALL(Ropeobj163009*, quotedfilename_167354)(Tlineinfo165338 i);
N_NIMCALL(void, HEX3Aanonymous_167371)(NU8 err, NimStringDesc* msg, NIM_BOOL usewarning);
STRING_LITERAL(TMP840, "unknown error", 13);
STRING_LITERAL(TMP841, "illformed AST: $1", 17);
STRING_LITERAL(TMP842, "internal error: $1", 18);
STRING_LITERAL(TMP843, "cannot open \'$1\'", 16);
STRING_LITERAL(TMP844, "$1", 2);
STRING_LITERAL(TMP845, "\'$1\' compiler does not support C++", 34);
STRING_LITERAL(TMP846, "string literal expected", 23);
STRING_LITERAL(TMP847, "integer literal expected", 24);
STRING_LITERAL(TMP848, "invalid character constant", 26);
STRING_LITERAL(TMP849, "closing \"\"\" expected, but end of file reached", 45);
STRING_LITERAL(TMP850, "closing \" expected", 18);
STRING_LITERAL(TMP851, "tabulators are not allowed", 26);
STRING_LITERAL(TMP852, "invalid token: $1", 17);
STRING_LITERAL(TMP853, "line too long", 13);
STRING_LITERAL(TMP854, "$1 is not a valid number", 24);
STRING_LITERAL(TMP855, "number $1 out of valid range", 28);
STRING_LITERAL(TMP856, "\\n not allowed in character literal", 35);
STRING_LITERAL(TMP857, "closing \']\' expected, but end of file reached", 45);
STRING_LITERAL(TMP858, "missing final \' for character literal", 37);
STRING_LITERAL(TMP859, "identifier expected, but found \'$1\'", 35);
STRING_LITERAL(TMP860, "newline expected, but found \'$1\'", 32);
STRING_LITERAL(TMP861, "invalid module name: \'$1\'", 25);
STRING_LITERAL(TMP862, "operator expected, but found \'$1\'", 33);
STRING_LITERAL(TMP863, "\'$1\' expected", 13);
STRING_LITERAL(TMP864, "string after \'include\' expected", 31);
STRING_LITERAL(TMP865, "recursive dependency: \'$1\'", 26);
STRING_LITERAL(TMP866, "\'on\' or \'off\' expected", 22);
STRING_LITERAL(TMP867, "\'none\', \'speed\' or \'size\' expected", 34);
STRING_LITERAL(TMP868, "invalid pragma", 14);
STRING_LITERAL(TMP869, "unknown pragma: \'$1\'", 20);
STRING_LITERAL(TMP870, "invalid directive: \'$1\'", 23);
STRING_LITERAL(TMP871, "\'pop\' without a \'push\' pragma", 29);
STRING_LITERAL(TMP872, "empty asm statement", 19);
STRING_LITERAL(TMP873, "invalid indentation", 19);
STRING_LITERAL(TMP874, "exception expected", 18);
STRING_LITERAL(TMP875, "exception already handled", 25);
STRING_LITERAL(TMP876, "\'yield\' only allowed in an iterator", 35);
STRING_LITERAL(TMP877, "\'yield\' cannot be used within \'try\' in a non-inlined iterator", 61);
STRING_LITERAL(TMP878, "invalid number of \'yield\' expressions", 37);
STRING_LITERAL(TMP879, "current routine cannot return an expression", 43);
STRING_LITERAL(TMP880, "redefinition of \'$1\'", 20);
STRING_LITERAL(TMP881, "statement not allowed after \'return\', \'break\', \'raise\' or \'cont"
"inue\'", 68);
STRING_LITERAL(TMP882, "statement expected", 18);
STRING_LITERAL(TMP883, "\'$1\' is no label", 16);
STRING_LITERAL(TMP884, "invalid command line option: \'$1\'", 33);
STRING_LITERAL(TMP885, "argument for command line option expected: \'$1\'", 47);
STRING_LITERAL(TMP886, "invalid argument for command line option: \'$1\'", 46);
STRING_LITERAL(TMP887, "invalid variable substitution in \'$1\'", 37);
STRING_LITERAL(TMP888, "unknown variable: \'$1\'", 22);
STRING_LITERAL(TMP889, "unknown C compiler: \'$1\'", 24);
STRING_LITERAL(TMP890, "\'on\' or \'off\' expected, but \'$1\' found", 38);
STRING_LITERAL(TMP891, "\'none\', \'boehm\' or \'refc\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP892, "\'none\', \'speed\' or \'size\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP893, "\'gui\', \'console\' or \'lib\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP894, "unknown OS: \'$1\'", 16);
STRING_LITERAL(TMP895, "unknown CPU: \'$1\'", 17);
STRING_LITERAL(TMP896, "\'c\', \'c++\' or \'yaml\' expected, but \'$1\' found", 45);
STRING_LITERAL(TMP897, "arguments can only be given if the \'--run\' option is selected", 61);
STRING_LITERAL(TMP898, "multiple assignment is not allowed", 34);
STRING_LITERAL(TMP899, "\':\' or \'=\' expected, but found \'$1\'", 35);
STRING_LITERAL(TMP900, "expression expected, but found \'$1\'", 35);
STRING_LITERAL(TMP901, "undeclared identifier: \'$1\'", 27);
STRING_LITERAL(TMP902, "ambiguous identifier: \'$1\' -- use a qualifier", 45);
STRING_LITERAL(TMP903, "type expected", 13);
STRING_LITERAL(TMP904, "system module needs \'$1\'", 24);
STRING_LITERAL(TMP905, "execution of an external program failed", 39);
STRING_LITERAL(TMP906, "overloaded \'$1\' leads to ambiguous calls", 40);
STRING_LITERAL(TMP907, "invalid argument for \'$1\'", 25);
STRING_LITERAL(TMP908, "statement has no effect", 23);
STRING_LITERAL(TMP909, "\'$1\' expects a type or value", 28);
STRING_LITERAL(TMP910, "\'$1\' expects an array type", 26);
STRING_LITERAL(TMP911, "\'$1\' cannot be instantiated because its body has not been compi"
"led yet", 70);
STRING_LITERAL(TMP912, "expression \'$1\' ambiguous in this context", 41);
STRING_LITERAL(TMP913, "division by zero", 16);
STRING_LITERAL(TMP914, "ordinal type expected", 21);
STRING_LITERAL(TMP915, "ordinal or float type expected", 30);
STRING_LITERAL(TMP916, "over- or underflow", 18);
STRING_LITERAL(TMP917, "cannot evalutate \'$1\' because type is not defined completely", 60);
STRING_LITERAL(TMP918, "\'chr\' expects an int in the range 0..255", 40);
STRING_LITERAL(TMP919, "\'dynlib\' requires \'exportc\'", 27);
STRING_LITERAL(TMP920, "undeclared field: \'$1\'", 22);
STRING_LITERAL(TMP921, "attempt to access a nil address", 31);
STRING_LITERAL(TMP922, "index out of bounds", 19);
STRING_LITERAL(TMP923, "index types do not match", 24);
STRING_LITERAL(TMP924, "\'[]\' operator invalid for this type", 35);
STRING_LITERAL(TMP925, "value out of set bounds", 23);
STRING_LITERAL(TMP926, "field initialized twice: \'$1\'", 29);
STRING_LITERAL(TMP927, "field \'$1\' not initialized", 26);
STRING_LITERAL(TMP928, "expression \'$1\' cannot be called", 32);
STRING_LITERAL(TMP929, "expression has no type", 22);
STRING_LITERAL(TMP930, "expression \'$1\' has no type (or is ambiguous)", 45);
STRING_LITERAL(TMP931, "\'cast\' not allowed in safe mode", 31);
STRING_LITERAL(TMP932, "expression cannot be casted to $1", 33);
STRING_LITERAL(TMP933, "\',\' or \')\' expected", 19);
STRING_LITERAL(TMP934, "\'{\' or \'(\' expected", 19);
STRING_LITERAL(TMP935, "section (\'type\', \'proc\', etc.) expected", 39);
STRING_LITERAL(TMP936, "range expected", 14);
STRING_LITERAL(TMP937, "\'magic\' only allowed in system module", 37);
STRING_LITERAL(TMP938, "power of two expected", 21);
STRING_LITERAL(TMP939, "string literal may not be empty", 31);
STRING_LITERAL(TMP940, "calling convention expected", 27);
STRING_LITERAL(TMP941, "a proc can only have one calling convention", 43);
STRING_LITERAL(TMP942, "symbol must be imported if \'lib\' pragma is used", 47);
STRING_LITERAL(TMP943, "expression must be of type \'bool\'", 33);
STRING_LITERAL(TMP944, "constant expression expected", 28);
STRING_LITERAL(TMP945, "duplicate case label", 20);
STRING_LITERAL(TMP946, "range is empty", 14);
STRING_LITERAL(TMP947, "selector must be of an ordinal type, float or string", 52);
STRING_LITERAL(TMP948, "selector must be of an ordinal type", 35);
STRING_LITERAL(TMP949, "ord($1) must not be negative", 28);
STRING_LITERAL(TMP950, "len($1) must be less than 32768", 31);
STRING_LITERAL(TMP951, "wrong number of variables", 25);
STRING_LITERAL(TMP952, "only a \'ref object\' can be raised", 33);
STRING_LITERAL(TMP953, "\'break\' only allowed in loop construct", 38);
STRING_LITERAL(TMP954, "type \'$1\' has unknown size", 26);
STRING_LITERAL(TMP955, "a constant can only be initialized with a constant expression", 61);
STRING_LITERAL(TMP956, "a constant needs a value", 24);
STRING_LITERAL(TMP957, "the result type cannot be on open array", 39);
STRING_LITERAL(TMP958, "computing the type\'s size produced an overflow", 46);
STRING_LITERAL(TMP959, "set is too large", 16);
STRING_LITERAL(TMP960, "base type of a set must be an ordinal", 37);
STRING_LITERAL(TMP961, "inheritance only works with non-final objects", 45);
STRING_LITERAL(TMP962, "inheritance only works with an enum", 35);
STRING_LITERAL(TMP963, "illegal recursion in type \'$1\'", 30);
STRING_LITERAL(TMP964, "cannot instantiate: \'$1\'", 24);
STRING_LITERAL(TMP965, "expression has no address", 25);
STRING_LITERAL(TMP966, "address of \'$1\' may not escape its stack frame", 46);
STRING_LITERAL(TMP967, "for a \'var\' type a variable needs to be passed", 46);
STRING_LITERAL(TMP968, "type mismatch", 13);
STRING_LITERAL(TMP969, "type mismatch: got (", 20);
STRING_LITERAL(TMP970, "but expected one of: ", 21);
STRING_LITERAL(TMP971, "but expected \'$1\'", 17);
STRING_LITERAL(TMP972, "ambiguous call; both $1 and $2 match for: $3", 44);
STRING_LITERAL(TMP973, "wrong number of arguments", 25);
STRING_LITERAL(TMP974, "\'$1\' cannot be passed to a procvar", 34);
STRING_LITERAL(TMP975, "$1 cannot be declared in parameter declaration", 46);
STRING_LITERAL(TMP976, "pragmas are only allowed in the header of a proc", 48);
STRING_LITERAL(TMP977, "implementation of \'$1\' is not allowed", 37);
STRING_LITERAL(TMP978, "implementation of \'$1\' expected", 31);
STRING_LITERAL(TMP979, "no symbol to borrow from found", 30);
STRING_LITERAL(TMP980, "value of type \'$1\' has to be discarded", 38);
STRING_LITERAL(TMP981, "statement returns no value that can be discarded", 48);
STRING_LITERAL(TMP982, "conversion from $1 to $2 is invalid", 35);
STRING_LITERAL(TMP983, "cannot bind parameter \'$1\' twice", 32);
STRING_LITERAL(TMP984, "invalid order in array constructor", 34);
STRING_LITERAL(TMP985, "invalid order in enum \'$1\'", 26);
STRING_LITERAL(TMP986, "enum \'$1\' has holes", 19);
STRING_LITERAL(TMP987, "\'except\' or \'finally\' expected", 30);
STRING_LITERAL(TMP988, "after catch all \'except\' or \'finally\' no section may follow", 59);
STRING_LITERAL(TMP989, "option expected, but found \'$1\'", 31);
STRING_LITERAL(TMP990, "\'$1\' is not a label", 19);
STRING_LITERAL(TMP991, "not all cases are covered", 25);
STRING_LITERAL(TMP992, "unknown substitution variable: \'$1\'", 35);
STRING_LITERAL(TMP993, "complex statement requires indentation", 38);
STRING_LITERAL(TMP994, "\'$1\' is not callable", 20);
STRING_LITERAL(TMP995, "no pragmas allowed for $1", 25);
STRING_LITERAL(TMP996, "no generic parameters allowed for $1", 36);
STRING_LITERAL(TMP997, "invalid param kind: \'$1\'", 24);
STRING_LITERAL(TMP998, "default argument invalid", 24);
STRING_LITERAL(TMP999, "named parameter has to be an identifier", 39);
STRING_LITERAL(TMP1000, "no return type allowed for $1", 29);
STRING_LITERAL(TMP1001, "a type conversion needs exactly one argument", 44);
STRING_LITERAL(TMP1002, "invalid pragma: $1", 18);
STRING_LITERAL(TMP1003, "$1 not allowed here", 19);
STRING_LITERAL(TMP1004, "invalid control flow: $1", 24);
STRING_LITERAL(TMP1005, "invalid type: \'$1\'", 18);
STRING_LITERAL(TMP1006, "\'[]\' needs a pointer or reference type", 38);
STRING_LITERAL(TMP1007, "invalid expression", 18);
STRING_LITERAL(TMP1008, "invalid expression: \'$1\'", 24);
STRING_LITERAL(TMP1009, "enum has no value \'$1\'", 22);
STRING_LITERAL(TMP1010, "named expression expected", 25);
STRING_LITERAL(TMP1011, "named expression not allowed here", 33);
STRING_LITERAL(TMP1012, "\'$1\' expects one type parameter", 31);
STRING_LITERAL(TMP1013, "array expects two type parameters", 33);
STRING_LITERAL(TMP1014, "invalid visibility: \'$1\'", 24);
STRING_LITERAL(TMP1015, "initialization not allowed here", 31);
STRING_LITERAL(TMP1016, "\'$1\' cannot be assigned to", 26);
STRING_LITERAL(TMP1017, "iterators can only be defined at the module\'s top level", 55);
STRING_LITERAL(TMP1018, "$1 needs a return type", 22);
STRING_LITERAL(TMP1019, "no return type declared", 23);
STRING_LITERAL(TMP1020, "invalid command: \'$1\'", 21);
STRING_LITERAL(TMP1021, "\'$1\' is only allowed at top level", 33);
STRING_LITERAL(TMP1022, "\'$1\' needs a parameter that has an object type", 46);
STRING_LITERAL(TMP1023, "template/macro instantiation too nested", 39);
STRING_LITERAL(TMP1024, "template/generic instantiation from here", 40);
STRING_LITERAL(TMP1025, "invalid index value for tuple subscript", 39);
STRING_LITERAL(TMP1026, "command expects a filename argument", 35);
STRING_LITERAL(TMP1027, "please, specify a main module in the project configuration file", 63);
STRING_LITERAL(TMP1028, "\'$1\' is not a concrete type.", 28);
STRING_LITERAL(TMP1029, "invalid section start", 21);
STRING_LITERAL(TMP1030, "grid table is not implemented", 29);
STRING_LITERAL(TMP1031, "general parse error", 19);
STRING_LITERAL(TMP1032, "new section expected", 20);
STRING_LITERAL(TMP1033, "whitespace expected, got \'$1\'", 29);
STRING_LITERAL(TMP1034, "\'$1\' is no valid index file", 27);
STRING_LITERAL(TMP1035, "cannot render reStructuredText element \'$1\'", 43);
STRING_LITERAL(TMP1036, "type \'var var\' is not allowed", 29);
STRING_LITERAL(TMP1037, "instantiate \'$1\' explicitly", 27);
STRING_LITERAL(TMP1038, "only a call operator can be a delegator", 39);
STRING_LITERAL(TMP1039, "\'$1\' is not a variable, constant or a proc name", 47);
STRING_LITERAL(TMP1040, "the macro body cannot be compiled, because the parameter \'$1\' h"
"as a generic type", 80);
STRING_LITERAL(TMP1041, "Destructor signature is too specific. A destructor must be asso"
"ciated will all instantiations of a generic type", 111);
STRING_LITERAL(TMP1042, "inline iterators can be used as parameters only for templates, "
"macros and other inline iterators", 96);
STRING_LITERAL(TMP1043, "\'$1\' expects two arguments", 26);
STRING_LITERAL(TMP1044, "\'$1\' expects object types", 25);
STRING_LITERAL(TMP1045, "\'$1\' can never be of this subtype", 33);
STRING_LITERAL(TMP1046, "interpretation requires too many iterations", 43);
STRING_LITERAL(TMP1047, "cannot evaluate \'$1\'", 20);
STRING_LITERAL(TMP1048, "field \'$1\' cannot be found", 26);
STRING_LITERAL(TMP1049, "invalid conversion from type \'$1\'", 33);
STRING_LITERAL(TMP1050, "assertion failed", 16);
STRING_LITERAL(TMP1051, "cannot generate code for \'$1\'", 29);
STRING_LITERAL(TMP1052, "$1 requires one parameter", 25);
STRING_LITERAL(TMP1053, "unhandled exception: $1", 23);
STRING_LITERAL(TMP1054, "macro returned a cyclic abstract syntax tree", 44);
STRING_LITERAL(TMP1055, "\'$1\' is no macro or template", 28);
STRING_LITERAL(TMP1056, "\'$1\' can have side effects", 26);
STRING_LITERAL(TMP1057, "iterator within for loop context expected", 41);
STRING_LITERAL(TMP1058, "\'let\' symbol requires an initialization", 39);
STRING_LITERAL(TMP1059, "a thread var cannot be initialized explicitly", 45);
STRING_LITERAL(TMP1060, "usage of \'$1\' is a user-defined error", 37);
STRING_LITERAL(TMP1061, "illegal capture \'$1\'", 20);
STRING_LITERAL(TMP1062, "\'$1\' cannot have \'closure\' calling convention", 45);
STRING_LITERAL(TMP1063, "\'$1\' can only be used in compile-time context", 45);
STRING_LITERAL(TMP1064, "cannot infer the type of the $1", 31);
STRING_LITERAL(TMP1065, "cannot infer the return type of the proc", 40);
STRING_LITERAL(TMP1066, "A nested proc can have generic parameters only when it is used "
"as an operand to another routine and the types of the generic pa"
"ramers can be inferred from the expected signature.", 178);
STRING_LITERAL(TMP1067, "The current compiler \'$1\' doesn\'t support the requested compila"
"tion target", 74);
STRING_LITERAL(TMP1068, "cannot open \'$1\' [CannotOpenFile]", 33);
STRING_LITERAL(TMP1069, "octal escape sequences do not exist; leading zero is ignored [O"
"ctalEscape]", 74);
STRING_LITERAL(TMP1070, "\'$1\' is never read [XIsNeverRead]", 33);
STRING_LITERAL(TMP1071, "\'$1\' might not have been initialized [XmightNotBeenInit]", 56);
STRING_LITERAL(TMP1072, "$1 is deprecated [Deprecated]", 29);
STRING_LITERAL(TMP1073, "config file \'$1\' is deprecated [ConfigDeprecated]", 49);
STRING_LITERAL(TMP1074, "\'l\' should not be used as an identifier; may look like \'1\' (one"
") [SmallLshouldNotBeUsed]", 88);
STRING_LITERAL(TMP1075, "unknown magic \'$1\' might crash the compiler [UnknownMagic]", 58);
STRING_LITERAL(TMP1076, "redefinition of label \'$1\' [RedefinitionOfLabel]", 48);
STRING_LITERAL(TMP1077, "unknown substitution \'$1\' [UnknownSubstitutionX]", 48);
STRING_LITERAL(TMP1078, "language \'$1\' not supported [LanguageXNotSupported]", 51);
STRING_LITERAL(TMP1079, "field \'$1\' not supported [FieldXNotSupported]", 45);
STRING_LITERAL(TMP1080, "comment \'$1\' ignored [CommentXIgnored]", 38);
STRING_LITERAL(TMP1081, "\'nil\' statement is deprecated; use an empty \'discard\' statement"
" instead [NilStmt]", 81);
STRING_LITERAL(TMP1082, "\'$1\' has no type. Typeless parameters are deprecated; only allo"
"wed for \'template\' [TypelessParam]", 97);
STRING_LITERAL(TMP1083, "possible inconsistency of thread local heaps [DifferentHeaps]", 61);
STRING_LITERAL(TMP1084, "write to foreign heap [WriteToForeignHeap]", 42);
STRING_LITERAL(TMP1085, "unsafe code: \'$1\' [UnsafeCode]", 30);
STRING_LITERAL(TMP1086, "each identifier is a tuple [EachIdentIsTuple]", 45);
STRING_LITERAL(TMP1087, "shadowed identifier: \'$1\' [ShadowIdent]", 39);
STRING_LITERAL(TMP1088, "Cannot prove that \'$1\' is initialized. This will become a compi"
"le time error in the future. [ProveInit]", 103);
STRING_LITERAL(TMP1089, "cannot prove that field \'$1\' is accessible [ProveField]", 55);
STRING_LITERAL(TMP1090, "cannot prove index \'$1\' is valid [ProveIndex]", 45);
STRING_LITERAL(TMP1091, "not GC-safe: \'$1\' [GcUnsafe]", 28);
STRING_LITERAL(TMP1092, "\'$1\' might not have been initialized [Uninit]", 45);
STRING_LITERAL(TMP1093, "\'$1\' uses GC\'ed memory [GcMem]", 30);
STRING_LITERAL(TMP1094, "usage of a type with a destructor in a non destructible context"
". This will become a compile time error in the future. [Destruct"
"or]", 130);
STRING_LITERAL(TMP1095, "$1 [LockLevel]", 14);
STRING_LITERAL(TMP1096, "Special variable \'result\' is shadowed. [ResultShadowed]", 55);
STRING_LITERAL(TMP1097, "$1 [User]", 9);
STRING_LITERAL(TMP1098, "operation successful [Success]", 30);
STRING_LITERAL(TMP1099, "operation successful ($# lines compiled; $# sec total; $#; $#) "
"[SuccessX]", 73);
STRING_LITERAL(TMP1100, "line too long [LineTooLong]", 27);
STRING_LITERAL(TMP1101, "\'$1\' is declared but not used [XDeclaredButNotUsed]", 51);
STRING_LITERAL(TMP1102, "conversion to base object is not needed [ConvToBaseNotNeeded]", 61);
STRING_LITERAL(TMP1103, "conversion from $1 to itself is pointless [ConvFromXtoItselfNot"
"Needed]", 70);
STRING_LITERAL(TMP1104, "expression evaluates always to \'$1\' [ExprAlwaysX]", 49);
STRING_LITERAL(TMP1105, "quit() called [QuitCalled]", 26);
STRING_LITERAL(TMP1106, "$1 [Processing]", 15);
STRING_LITERAL(TMP1107, "generated code listing: [CodeBegin]", 35);
STRING_LITERAL(TMP1108, "end of listing [CodeEnd]", 24);
STRING_LITERAL(TMP1109, "used config file \'$1\' [Conf]", 28);
STRING_LITERAL(TMP1110, "added path: \'$1\' [Path]", 23);
STRING_LITERAL(TMP1111, "condition is always true: \'$1\' [CondTrue]", 41);
STRING_LITERAL(TMP1112, "name should be: \'$1\' [Name]", 27);
STRING_LITERAL(TMP1113, "$1 [Pattern]", 12);
NIM_CONST TY165288 Msgkindtostr_165287 = {((NimStringDesc*) &TMP840),
((NimStringDesc*) &TMP841),
((NimStringDesc*) &TMP842),
((NimStringDesc*) &TMP843),
((NimStringDesc*) &TMP844),
((NimStringDesc*) &TMP845),
((NimStringDesc*) &TMP846),
((NimStringDesc*) &TMP847),
((NimStringDesc*) &TMP848),
((NimStringDesc*) &TMP849),
((NimStringDesc*) &TMP850),
((NimStringDesc*) &TMP851),
((NimStringDesc*) &TMP852),
((NimStringDesc*) &TMP853),
((NimStringDesc*) &TMP854),
((NimStringDesc*) &TMP855),
((NimStringDesc*) &TMP856),
((NimStringDesc*) &TMP857),
((NimStringDesc*) &TMP858),
((NimStringDesc*) &TMP859),
((NimStringDesc*) &TMP860),
((NimStringDesc*) &TMP861),
((NimStringDesc*) &TMP862),
((NimStringDesc*) &TMP863),
((NimStringDesc*) &TMP864),
((NimStringDesc*) &TMP865),
((NimStringDesc*) &TMP866),
((NimStringDesc*) &TMP867),
((NimStringDesc*) &TMP868),
((NimStringDesc*) &TMP869),
((NimStringDesc*) &TMP870),
((NimStringDesc*) &TMP871),
((NimStringDesc*) &TMP872),
((NimStringDesc*) &TMP873),
((NimStringDesc*) &TMP874),
((NimStringDesc*) &TMP875),
((NimStringDesc*) &TMP876),
((NimStringDesc*) &TMP877),
((NimStringDesc*) &TMP878),
((NimStringDesc*) &TMP879),
((NimStringDesc*) &TMP880),
((NimStringDesc*) &TMP881),
((NimStringDesc*) &TMP882),
((NimStringDesc*) &TMP883),
((NimStringDesc*) &TMP884),
((NimStringDesc*) &TMP885),
((NimStringDesc*) &TMP886),
((NimStringDesc*) &TMP887),
((NimStringDesc*) &TMP888),
((NimStringDesc*) &TMP889),
((NimStringDesc*) &TMP890),
((NimStringDesc*) &TMP891),
((NimStringDesc*) &TMP892),
((NimStringDesc*) &TMP893),
((NimStringDesc*) &TMP894),
((NimStringDesc*) &TMP895),
((NimStringDesc*) &TMP896),
((NimStringDesc*) &TMP897),
((NimStringDesc*) &TMP898),
((NimStringDesc*) &TMP899),
((NimStringDesc*) &TMP900),
((NimStringDesc*) &TMP901),
((NimStringDesc*) &TMP902),
((NimStringDesc*) &TMP903),
((NimStringDesc*) &TMP904),
((NimStringDesc*) &TMP905),
((NimStringDesc*) &TMP906),
((NimStringDesc*) &TMP907),
((NimStringDesc*) &TMP908),
((NimStringDesc*) &TMP909),
((NimStringDesc*) &TMP910),
((NimStringDesc*) &TMP911),
((NimStringDesc*) &TMP912),
((NimStringDesc*) &TMP913),
((NimStringDesc*) &TMP914),
((NimStringDesc*) &TMP915),
((NimStringDesc*) &TMP916),
((NimStringDesc*) &TMP917),
((NimStringDesc*) &TMP918),
((NimStringDesc*) &TMP919),
((NimStringDesc*) &TMP920),
((NimStringDesc*) &TMP921),
((NimStringDesc*) &TMP922),
((NimStringDesc*) &TMP923),
((NimStringDesc*) &TMP924),
((NimStringDesc*) &TMP925),
((NimStringDesc*) &TMP926),
((NimStringDesc*) &TMP927),
((NimStringDesc*) &TMP928),
((NimStringDesc*) &TMP929),
((NimStringDesc*) &TMP930),
((NimStringDesc*) &TMP931),
((NimStringDesc*) &TMP932),
((NimStringDesc*) &TMP933),
((NimStringDesc*) &TMP934),
((NimStringDesc*) &TMP935),
((NimStringDesc*) &TMP936),
((NimStringDesc*) &TMP937),
((NimStringDesc*) &TMP938),
((NimStringDesc*) &TMP939),
((NimStringDesc*) &TMP940),
((NimStringDesc*) &TMP941),
((NimStringDesc*) &TMP942),
((NimStringDesc*) &TMP943),
((NimStringDesc*) &TMP944),
((NimStringDesc*) &TMP945),
((NimStringDesc*) &TMP946),
((NimStringDesc*) &TMP947),
((NimStringDesc*) &TMP948),
((NimStringDesc*) &TMP949),
((NimStringDesc*) &TMP950),
((NimStringDesc*) &TMP951),
((NimStringDesc*) &TMP952),
((NimStringDesc*) &TMP953),
((NimStringDesc*) &TMP954),
((NimStringDesc*) &TMP955),
((NimStringDesc*) &TMP956),
((NimStringDesc*) &TMP957),
((NimStringDesc*) &TMP958),
((NimStringDesc*) &TMP959),
((NimStringDesc*) &TMP960),
((NimStringDesc*) &TMP961),
((NimStringDesc*) &TMP962),
((NimStringDesc*) &TMP963),
((NimStringDesc*) &TMP964),
((NimStringDesc*) &TMP965),
((NimStringDesc*) &TMP966),
((NimStringDesc*) &TMP967),
((NimStringDesc*) &TMP968),
((NimStringDesc*) &TMP969),
((NimStringDesc*) &TMP970),
((NimStringDesc*) &TMP971),
((NimStringDesc*) &TMP972),
((NimStringDesc*) &TMP973),
((NimStringDesc*) &TMP974),
((NimStringDesc*) &TMP975),
((NimStringDesc*) &TMP976),
((NimStringDesc*) &TMP977),
((NimStringDesc*) &TMP978),
((NimStringDesc*) &TMP979),
((NimStringDesc*) &TMP980),
((NimStringDesc*) &TMP981),
((NimStringDesc*) &TMP982),
((NimStringDesc*) &TMP983),
((NimStringDesc*) &TMP984),
((NimStringDesc*) &TMP985),
((NimStringDesc*) &TMP986),
((NimStringDesc*) &TMP987),
((NimStringDesc*) &TMP988),
((NimStringDesc*) &TMP989),
((NimStringDesc*) &TMP990),
((NimStringDesc*) &TMP991),
((NimStringDesc*) &TMP992),
((NimStringDesc*) &TMP993),
((NimStringDesc*) &TMP994),
((NimStringDesc*) &TMP995),
((NimStringDesc*) &TMP996),
((NimStringDesc*) &TMP997),
((NimStringDesc*) &TMP998),
((NimStringDesc*) &TMP999),
((NimStringDesc*) &TMP1000),
((NimStringDesc*) &TMP1001),
((NimStringDesc*) &TMP1002),
((NimStringDesc*) &TMP1003),
((NimStringDesc*) &TMP1004),
((NimStringDesc*) &TMP1005),
((NimStringDesc*) &TMP1006),
((NimStringDesc*) &TMP1007),
((NimStringDesc*) &TMP1008),
((NimStringDesc*) &TMP1009),
((NimStringDesc*) &TMP1010),
((NimStringDesc*) &TMP1011),
((NimStringDesc*) &TMP1012),
((NimStringDesc*) &TMP1013),
((NimStringDesc*) &TMP1014),
((NimStringDesc*) &TMP1015),
((NimStringDesc*) &TMP1016),
((NimStringDesc*) &TMP1017),
((NimStringDesc*) &TMP1018),
((NimStringDesc*) &TMP1019),
((NimStringDesc*) &TMP1020),
((NimStringDesc*) &TMP1021),
((NimStringDesc*) &TMP1022),
((NimStringDesc*) &TMP1023),
((NimStringDesc*) &TMP1024),
((NimStringDesc*) &TMP1025),
((NimStringDesc*) &TMP1026),
((NimStringDesc*) &TMP1027),
((NimStringDesc*) &TMP863),
((NimStringDesc*) &TMP1028),
((NimStringDesc*) &TMP1029),
((NimStringDesc*) &TMP1030),
((NimStringDesc*) &TMP1031),
((NimStringDesc*) &TMP1032),
((NimStringDesc*) &TMP1033),
((NimStringDesc*) &TMP1034),
((NimStringDesc*) &TMP1035),
((NimStringDesc*) &TMP1036),
((NimStringDesc*) &TMP1037),
((NimStringDesc*) &TMP1038),
((NimStringDesc*) &TMP1039),
((NimStringDesc*) &TMP1040),
((NimStringDesc*) &TMP1041),
((NimStringDesc*) &TMP1042),
((NimStringDesc*) &TMP1043),
((NimStringDesc*) &TMP1044),
((NimStringDesc*) &TMP1045),
((NimStringDesc*) &TMP1046),
((NimStringDesc*) &TMP1047),
((NimStringDesc*) &TMP1048),
((NimStringDesc*) &TMP1049),
((NimStringDesc*) &TMP1050),
((NimStringDesc*) &TMP1051),
((NimStringDesc*) &TMP1052),
((NimStringDesc*) &TMP1053),
((NimStringDesc*) &TMP1054),
((NimStringDesc*) &TMP1055),
((NimStringDesc*) &TMP1056),
((NimStringDesc*) &TMP1057),
((NimStringDesc*) &TMP1058),
((NimStringDesc*) &TMP1059),
((NimStringDesc*) &TMP1060),
((NimStringDesc*) &TMP1061),
((NimStringDesc*) &TMP1062),
((NimStringDesc*) &TMP1063),
((NimStringDesc*) &TMP1064),
((NimStringDesc*) &TMP1065),
((NimStringDesc*) &TMP1066),
((NimStringDesc*) &TMP1067),
((NimStringDesc*) &TMP844),
((NimStringDesc*) &TMP1068),
((NimStringDesc*) &TMP1069),
((NimStringDesc*) &TMP1070),
((NimStringDesc*) &TMP1071),
((NimStringDesc*) &TMP1072),
((NimStringDesc*) &TMP1073),
((NimStringDesc*) &TMP1074),
((NimStringDesc*) &TMP1075),
((NimStringDesc*) &TMP1076),
((NimStringDesc*) &TMP1077),
((NimStringDesc*) &TMP1078),
((NimStringDesc*) &TMP1079),
((NimStringDesc*) &TMP1080),
((NimStringDesc*) &TMP1081),
((NimStringDesc*) &TMP1082),
((NimStringDesc*) &TMP1083),
((NimStringDesc*) &TMP1084),
((NimStringDesc*) &TMP1085),
((NimStringDesc*) &TMP1086),
((NimStringDesc*) &TMP1087),
((NimStringDesc*) &TMP1088),
((NimStringDesc*) &TMP1089),
((NimStringDesc*) &TMP1090),
((NimStringDesc*) &TMP1091),
((NimStringDesc*) &TMP844),
((NimStringDesc*) &TMP1092),
((NimStringDesc*) &TMP1093),
((NimStringDesc*) &TMP1094),
((NimStringDesc*) &TMP1095),
((NimStringDesc*) &TMP1096),
((NimStringDesc*) &TMP1097),
((NimStringDesc*) &TMP1098),
((NimStringDesc*) &TMP1099),
((NimStringDesc*) &TMP1100),
((NimStringDesc*) &TMP1101),
((NimStringDesc*) &TMP1102),
((NimStringDesc*) &TMP1103),
((NimStringDesc*) &TMP1104),
((NimStringDesc*) &TMP1105),
((NimStringDesc*) &TMP1106),
((NimStringDesc*) &TMP1107),
((NimStringDesc*) &TMP1108),
((NimStringDesc*) &TMP1109),
((NimStringDesc*) &TMP1110),
((NimStringDesc*) &TMP1111),
((NimStringDesc*) &TMP1112),
((NimStringDesc*) &TMP1113),
((NimStringDesc*) &TMP1097)}
;
STRING_LITERAL(TMP1114, "CannotOpenFile", 14);
STRING_LITERAL(TMP1115, "OctalEscape", 11);
STRING_LITERAL(TMP1116, "XIsNeverRead", 12);
STRING_LITERAL(TMP1117, "XmightNotBeenInit", 17);
STRING_LITERAL(TMP1118, "Deprecated", 10);
STRING_LITERAL(TMP1119, "ConfigDeprecated", 16);
STRING_LITERAL(TMP1120, "SmallLshouldNotBeUsed", 21);
STRING_LITERAL(TMP1121, "UnknownMagic", 12);
STRING_LITERAL(TMP1122, "RedefinitionOfLabel", 19);
STRING_LITERAL(TMP1123, "UnknownSubstitutionX", 20);
STRING_LITERAL(TMP1124, "LanguageXNotSupported", 21);
STRING_LITERAL(TMP1125, "FieldXNotSupported", 18);
STRING_LITERAL(TMP1126, "CommentXIgnored", 15);
STRING_LITERAL(TMP1127, "NilStmt", 7);
STRING_LITERAL(TMP1128, "TypelessParam", 13);
STRING_LITERAL(TMP1129, "DifferentHeaps", 14);
STRING_LITERAL(TMP1130, "WriteToForeignHeap", 18);
STRING_LITERAL(TMP1131, "UnsafeCode", 10);
STRING_LITERAL(TMP1132, "EachIdentIsTuple", 16);
STRING_LITERAL(TMP1133, "ShadowIdent", 11);
STRING_LITERAL(TMP1134, "ProveInit", 9);
STRING_LITERAL(TMP1135, "ProveField", 10);
STRING_LITERAL(TMP1136, "ProveIndex", 10);
STRING_LITERAL(TMP1137, "GcUnsafe", 8);
STRING_LITERAL(TMP1138, "GcUnsafe2", 9);
STRING_LITERAL(TMP1139, "Uninit", 6);
STRING_LITERAL(TMP1140, "GcMem", 5);
STRING_LITERAL(TMP1141, "Destructor", 10);
STRING_LITERAL(TMP1142, "LockLevel", 9);
STRING_LITERAL(TMP1143, "ResultShadowed", 14);
STRING_LITERAL(TMP1144, "User", 4);
NIM_CONST TY165297 Warningstostr_165296 = {((NimStringDesc*) &TMP1114),
((NimStringDesc*) &TMP1115),
((NimStringDesc*) &TMP1116),
((NimStringDesc*) &TMP1117),
((NimStringDesc*) &TMP1118),
((NimStringDesc*) &TMP1119),
((NimStringDesc*) &TMP1120),
((NimStringDesc*) &TMP1121),
((NimStringDesc*) &TMP1122),
((NimStringDesc*) &TMP1123),
((NimStringDesc*) &TMP1124),
((NimStringDesc*) &TMP1125),
((NimStringDesc*) &TMP1126),
((NimStringDesc*) &TMP1127),
((NimStringDesc*) &TMP1128),
((NimStringDesc*) &TMP1129),
((NimStringDesc*) &TMP1130),
((NimStringDesc*) &TMP1131),
((NimStringDesc*) &TMP1132),
((NimStringDesc*) &TMP1133),
((NimStringDesc*) &TMP1134),
((NimStringDesc*) &TMP1135),
((NimStringDesc*) &TMP1136),
((NimStringDesc*) &TMP1137),
((NimStringDesc*) &TMP1138),
((NimStringDesc*) &TMP1139),
((NimStringDesc*) &TMP1140),
((NimStringDesc*) &TMP1141),
((NimStringDesc*) &TMP1142),
((NimStringDesc*) &TMP1143),
((NimStringDesc*) &TMP1144)}
;
STRING_LITERAL(TMP1145, "Success", 7);
STRING_LITERAL(TMP1146, "SuccessX", 8);
STRING_LITERAL(TMP1147, "LineTooLong", 11);
STRING_LITERAL(TMP1148, "XDeclaredButNotUsed", 19);
STRING_LITERAL(TMP1149, "ConvToBaseNotNeeded", 19);
STRING_LITERAL(TMP1150, "ConvFromXtoItselfNotNeeded", 26);
STRING_LITERAL(TMP1151, "ExprAlwaysX", 11);
STRING_LITERAL(TMP1152, "QuitCalled", 10);
STRING_LITERAL(TMP1153, "Processing", 10);
STRING_LITERAL(TMP1154, "CodeBegin", 9);
STRING_LITERAL(TMP1155, "CodeEnd", 7);
STRING_LITERAL(TMP1156, "Conf", 4);
STRING_LITERAL(TMP1157, "Path", 4);
STRING_LITERAL(TMP1158, "CondTrue", 8);
STRING_LITERAL(TMP1159, "Name", 4);
STRING_LITERAL(TMP1160, "Pattern", 7);
NIM_CONST TY165302 Hintstostr_165301 = {((NimStringDesc*) &TMP1145),
((NimStringDesc*) &TMP1146),
((NimStringDesc*) &TMP1147),
((NimStringDesc*) &TMP1148),
((NimStringDesc*) &TMP1149),
((NimStringDesc*) &TMP1150),
((NimStringDesc*) &TMP1151),
((NimStringDesc*) &TMP1152),
((NimStringDesc*) &TMP1153),
((NimStringDesc*) &TMP1154),
((NimStringDesc*) &TMP1155),
((NimStringDesc*) &TMP1156),
((NimStringDesc*) &TMP1157),
((NimStringDesc*) &TMP1158),
((NimStringDesc*) &TMP1159),
((NimStringDesc*) &TMP1160),
((NimStringDesc*) &TMP1144)}
;
STRING_LITERAL(TMP1172, "\"", 1);
STRING_LITERAL(TMP1177, "", 0);
STRING_LITERAL(TMP1189, "command line", 12);
STRING_LITERAL(TMP1190, "compilation artifact", 20);
STRING_LITERAL(TMP1194, "\015\012", 2);
STRING_LITERAL(TMP1197, "suggest done", 12);
STRING_LITERAL(TMP1200, "???", 3);
STRING_LITERAL(TMP1201, "0 <= fileIdx ", 13);
STRING_LITERAL(TMP1202, ":", 1);
STRING_LITERAL(TMP1203, "(", 1);
STRING_LITERAL(TMP1204, ",", 1);
STRING_LITERAL(TMP1205, ")", 1);
STRING_LITERAL(TMP1234, "No stack traceback available\015\012To create a stacktrace, rerun com"
"pilation with ./koch temp ", 89);
STRING_LITERAL(TMP1235, " <file>", 7);
STRING_LITERAL(TMP1238, "$1($2, $3) Info: $4", 19);
STRING_LITERAL(TMP1241, "Error: $1", 9);
STRING_LITERAL(TMP1242, "Warning: $1", 11);
STRING_LITERAL(TMP1244, "Hint: $1", 8);
STRING_LITERAL(TMP1247, "  ", 2);
STRING_LITERAL(TMP1248, "$1($2, $3) Warning: $4", 22);
STRING_LITERAL(TMP1249, "$1($2, $3) Hint: $4", 19);
STRING_LITERAL(TMP1250, "$1($2, $3) Error: $4", 20);
STRING_LITERAL(TMP1261, "compiler/msgs.nim", 17);
NIM_CONST TY149210 TMP1260 = {((NimStringDesc*) &TMP1261),
((NI) 868)}
;
NIM_CONST TY149210 TMP1263 = {((NimStringDesc*) &TMP1261),
((NI) 875)}
;
STRING_LITERAL(TMP1264, "ropes: invalid format string: ", 30);
Table165376 filenametoindextbl_165414;
extern TNimType NTI165376; /* Table */
TY165415* fileinfos_165432;
TNimType NTI165336; /* TFileInfo */
extern TNimType NTI149; /* string */
extern TNimType NTI163007; /* Rope */
extern TNimType NTI163599; /* seq[Rope] */
TNimType NTI165415; /* seq[TFileInfo] */
extern TFrame* frameptr_17042;
extern Tgcheap48616 gch_48644;
NI32 systemfileidx_165433;
extern NimStringDesc* tnl_161626;
extern NU32 gglobaloptions_156128;
extern TSafePoint* exchandler_17043;
extern Exception* currexception_17045;
Tlineinfo165338 gcmdlineinfo_165921;
Tlineinfo165338 gcodegenlineinfo_165959;
extern TNimType NTI3449; /* ValueError */
TNimType NTI165344; /* ERecoverableError */
TNimType NTI165972; /* ref ERecoverableError */
NU64 gnotes_166011;
NI gerrorcounter_166012;
NI ghintcounter_166013;
NI gwarncounter_166014;
NI gerrormax_166015;
TY166033* msgcontext_166050;
TNimType NTI165338; /* TLineInfo */
extern TNimType NTI112; /* int16 */
extern TNimType NTI114; /* int32 */
TNimType NTI166033; /* seq[TLineInfo] */
Tlineinfo165338 lasterror_166051;
NU8 erroroutputs_166053;
TY166054 writelnhook_166057;
extern TNimType NTI3427; /* Exception */
TNimType NTI165346; /* ESuggestDone */
TNimType NTI166127; /* ref ESuggestDone */
extern NIM_BOOL glistfullpaths_156142;
Tlineinfo165338 gtrackpos_166500;
extern NI gverbosity_156137;
extern NimStringDesc* command_156239;
extern NI8 gexitcode_156129;
extern NU8 gcmd_156130;
extern NU32 goptions_156126;
extern TNimType NTI3431; /* IOError */
extern TY163023 errorhandler_163028;
TNimType NTI165005; /* TMsgKind */
TNimType NTI165332; /* TNoteKind */
TNimType NTI165334; /* TNoteKinds */
N_NIMCALL(void, TMP1166)(void* p, NI op) {
	TY165415* a;
	NI LOC1;
	a = (TY165415*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	nimGCvisit((void*)a->data[LOC1].fullpath, op);
	nimGCvisit((void*)a->data[LOC1].projpath, op);
	nimGCvisit((void*)a->data[LOC1].shortname, op);
	nimGCvisit((void*)a->data[LOC1].quotedname, op);
	nimGCvisit((void*)a->data[LOC1].lines, op);
	nimGCvisit((void*)a->data[LOC1].dirtyfile, op);
	}
}

static N_INLINE(void, nimFrame)(TFrame* s) {
	NI LOC1;
	LOC1 = 0;
	{
		if (!(frameptr_17042 == NIM_NIL)) goto LA4;
		LOC1 = ((NI) 0);
	}
	goto LA2;
	LA4: ;
	{
		LOC1 = ((NI) ((NI16)((*frameptr_17042).calldepth + ((NI16) 1))));
	}
	LA2: ;
	(*s).calldepth = ((NI16) (LOC1));
	(*s).prev = frameptr_17042;
	frameptr_17042 = s;
	{
		if (!((*s).calldepth == ((NI16) 2000))) goto LA9;
		stackoverflow_20001();
	}
	LA9: ;
}

static N_INLINE(void, popFrame)(void) {
	frameptr_17042 = (*frameptr_17042).prev;
}

static N_INLINE(Tcell46746*, usrtocell_50246)(void* usr) {
	Tcell46746* result;
	nimfr("usrToCell", "gc.nim")
	result = 0;
	nimln(118, "gc.nim");
	result = ((Tcell46746*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(Tcell46746))))));
	popFrame();
	return result;
}

static N_INLINE(void, rtladdzct_51804)(Tcell46746* c) {
	nimfr("rtlAddZCT", "gc.nim")
	nimln(199, "gc.nim");
	addzct_50217((&gch_48644.zct), c);
	popFrame();
}

static N_INLINE(void, nimGCunrefNoCycle)(void* p) {
	Tcell46746* c;
	nimfr("nimGCunrefNoCycle", "gc.nim")
	nimln(233, "gc.nim");
	c = usrtocell_50246(p);
	nimln(235, "gc.nim");
	{
		nimln(167, "gc.nim");
		(*c).refcount -= ((NI) 8);
		nimln(168, "gc.nim");
		if (!((NU64)((*c).refcount) < (NU64)(((NI) 8)))) goto LA3;
		nimln(236, "gc.nim");
		rtladdzct_51804(c);
	}
	LA3: ;
	popFrame();
}

static N_INLINE(void, appendChar)(NimStringDesc* dest, NIM_CHAR c) {
	(*dest).data[((*dest).Sup.len)- 0] = c;
	(*dest).data[((NI)((*dest).Sup.len + ((NI) 1)))- 0] = 0;
	(*dest).Sup.len += ((NI) 1);
}

static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) ((&(*dest).data[((*dest).Sup.len)- 0]))), ((NCSTRING) ((*src).data)), (NI)((*src).Sup.len + ((NI) 1)));
	(*dest).Sup.len += (*src).Sup.len;
}

N_NIMCALL(NimStringDesc*, tocchar_165439)(NIM_CHAR c) {
	NimStringDesc* result;
	nimfr("toCChar", "msgs.nim")
	result = 0;
	nimln(491, "msgs.nim");
	switch (((NU8)(c))) {
	case 0 ... 31:
	case 128 ... 255:
	{
		NimStringDesc* LOC2;
		NimStringDesc* LOC3;
		nimln(492, "msgs.nim");
		LOC2 = 0;
		LOC3 = 0;
		LOC3 = nsuToOctal(c);
		LOC2 = rawNewString(LOC3->Sup.len + 1);
appendChar(LOC2, 92);
appendString(LOC2, LOC3);
		result = LOC2;
	}
	break;
	case 39:
	case 34:
	case 92:
	{
		NimStringDesc* LOC5;
		nimln(493, "msgs.nim");
		LOC5 = 0;
		LOC5 = rawNewString(2);
appendChar(LOC5, 92);
appendChar(LOC5, c);
		result = LOC5;
	}
	break;
	default:
	{
		nimln(494, "msgs.nim");
		result = nimCharToStr(c);
	}
	break;
	}
	popFrame();
	return result;
}

static N_INLINE(NI, addInt)(NI a, NI b) {
	NI result;
{	result = 0;
	result = (NI)((NU64)(a) + (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (((NI) 0) <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (((NI) 0) <= (NI)(result ^ b));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	}BeforeRet: ;
	return result;
}

static N_INLINE(NI, chckRange)(NI i, NI a, NI b) {
	NI result;
{	result = 0;
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (a <= i);
		if (!(LOC3)) goto LA4;
		LOC3 = (i <= b);
		LA4: ;
		if (!LOC3) goto LA5;
		result = i;
		goto BeforeRet;
	}
	goto LA1;
	LA5: ;
	{
		raiseRangeError(((NI64) (i)));
	}
	LA1: ;
	}BeforeRet: ;
	return result;
}

static N_INLINE(NI, subInt)(NI a, NI b) {
	NI result;
{	result = 0;
	result = (NI)((NU64)(a) - (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (((NI) 0) <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (((NI) 0) <= (NI)(result ^ (NI)((NU64) ~(b))));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	}BeforeRet: ;
	return result;
}

static N_INLINE(NI, modInt)(NI a, NI b) {
	NI result;
{	result = 0;
	{
		if (!(b == ((NI) 0))) goto LA3;
		raiseDivByZero();
	}
	LA3: ;
	result = (NI)(a % b);
	goto BeforeRet;
	}BeforeRet: ;
	return result;
}

N_NIMCALL(Ropeobj163009*, makecstring_165449)(NimStringDesc* s) {
	Ropeobj163009* result;
	NimStringDesc* res;
	NI TMP1171;
	Ropeobj163009* LOC9;
	nimfr("makeCString", "msgs.nim")
	result = 0;
	nimln(499, "msgs.nim");
	result = NIM_NIL;
	nimln(500, "msgs.nim");
	TMP1171 = addInt(((NI) (((NF)(((double) ((s ? s->Sup.len : 0)))) * (NF)(1.1000000000000001e+00)))), ((NI) 1));
	res = rawNewString(((NI)chckRange((NI)(TMP1171), ((NI) 0), ((NI) IL64(9223372036854775807)))));
	nimln(501, "msgs.nim");
	res = resizeString(res, 1);
appendString(res, ((NimStringDesc*) &TMP1172));
	{
		NI i_165468;
		NI HEX3Atmp_165473;
		NI TMP1173;
		NI res_165476;
		i_165468 = 0;
		HEX3Atmp_165473 = 0;
		nimln(502, "msgs.nim");
		TMP1173 = subInt((s ? s->Sup.len : 0), ((NI) 1));
		HEX3Atmp_165473 = (NI)(TMP1173);
		nimln(1598, "system.nim");
		res_165476 = ((NI) 0);
		{
			nimln(1599, "system.nim");
			while (1) {
				NimStringDesc* LOC8;
				NI TMP1176;
				if (!(res_165476 <= HEX3Atmp_165473)) goto LA3;
				nimln(1600, "system.nim");
				i_165468 = res_165476;
				nimln(503, "msgs.nim");
				{
					NI TMP1174;
					NI TMP1175;
					TMP1174 = addInt(i_165468, ((NI) 1));
					TMP1175 = modInt((NI)(TMP1174), ((NI) 64));
					if (!(((NI) ((NI)(TMP1175))) == ((NI) 0))) goto LA6;
					nimln(504, "msgs.nim");
					res = addChar(res, 34);
					nimln(505, "msgs.nim");
					res = resizeString(res, tnl_161626->Sup.len + 0);
appendString(res, tnl_161626);
					nimln(506, "msgs.nim");
					res = addChar(res, 34);
				}
				LA6: ;
				nimln(507, "msgs.nim");
				if ((NU)(i_165468) > (NU)(s->Sup.len)) raiseIndexError();
				LOC8 = 0;
				LOC8 = tocchar_165439(s->data[i_165468]);
				res = resizeString(res, LOC8->Sup.len + 0);
appendString(res, LOC8);
				nimln(1614, "system.nim");
				TMP1176 = addInt(res_165476, ((NI) 1));
				res_165476 = (NI)(TMP1176);
			} LA3: ;
		}
	}
	nimln(508, "msgs.nim");
	res = addChar(res, 34);
	nimln(509, "msgs.nim");
	LOC9 = 0;
	LOC9 = rope_163320(res);
	add_163534(&result, LOC9);
	popFrame();
	return result;
}

N_NIMCALL(void, newfileinfo_165495)(NimStringDesc* fullpath, NimStringDesc* projpath, Tfileinfo165336* Result) {
	NimStringDesc* filename;
	nimfr("newFileInfo", "msgs.nim")
	nimln(513, "msgs.nim");
	unsureAsgnRef((void**) (&(*Result).fullpath), copyString(fullpath));
	nimln(515, "msgs.nim");
	unsureAsgnRef((void**) (&(*Result).projpath), copyString(projpath));
	nimln(517, "msgs.nim");
	filename = nosextractFilename(projpath);
	nimln(518, "msgs.nim");
	unsureAsgnRef((void**) (&(*Result).shortname), noschangeFileExt(filename, ((NimStringDesc*) &TMP1177)));
	nimln(519, "msgs.nim");
	unsureAsgnRef((void**) (&(*Result).quotedname), makecstring_165449(filename));
	nimln(520, "msgs.nim");
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = ((gglobaloptions_156128 &(1<<((((NU8) 27))&31)))!=0);
		if (LOC3) goto LA4;
		LOC3 = NIM_TRUE;
		LA4: ;
		if (!LOC3) goto LA5;
		nimln(521, "msgs.nim");
		unsureAsgnRef((void**) (&(*Result).lines), (TY163599*) newSeq((&NTI163599), 0));
	}
	LA5: ;
	popFrame();
}

static N_INLINE(NIM_BOOL, isfilled_158211)(NI hcode) {
	NIM_BOOL result;
	nimfr("isFilled", "tables.nim")
	result = 0;
	nimln(92, "tables.nim");
	result = !((hcode == ((NI) 0)));
	popFrame();
	return result;
}

static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b) {
	NIM_BOOL result;
	NIM_BOOL LOC11;
	int LOC13;
{	result = 0;
	{
		if (!(a == b)) goto LA3;
		result = NIM_TRUE;
		goto BeforeRet;
	}
	LA3: ;
	{
		NIM_BOOL LOC7;
		LOC7 = 0;
		LOC7 = (a == NIM_NIL);
		if (LOC7) goto LA8;
		LOC7 = (b == NIM_NIL);
		LA8: ;
		if (!LOC7) goto LA9;
		result = NIM_FALSE;
		goto BeforeRet;
	}
	LA9: ;
	LOC11 = 0;
	LOC11 = ((*a).Sup.len == (*b).Sup.len);
	if (!(LOC11)) goto LA12;
	LOC13 = 0;
	LOC13 = memcmp(((NCSTRING) ((*a).data)), ((NCSTRING) ((*b).data)), (*a).Sup.len);
	LOC11 = (LOC13 == ((NI32) 0));
	LA12: ;
	result = LOC11;
	goto BeforeRet;
	}BeforeRet: ;
	return result;
}

static N_INLINE(NI, nexttry_158420)(NI h, NI maxhash) {
	NI result;
	NI TMP1179;
	nimfr("nextTry", "tables.nim")
	result = 0;
	nimln(141, "tables.nim");
	TMP1179 = addInt(h, ((NI) 1));
	result = (NI)((NI)(TMP1179) & maxhash);
	popFrame();
	return result;
}

static N_INLINE(NI, rawget_165555)(Table165376 t, NimStringDesc* key, NI* hc) {
	NI result;
	NI h;
	NI TMP1180;
	nimfr("rawGet", "tables.nim")
{	result = 0;
	nimln(156, "tables.nim");
	(*hc) = hash_134839(key);
	nimln(157, "tables.nim");
	{
		if (!((*hc) == ((NI) 0))) goto LA3;
		nimln(158, "tables.nim");
		(*hc) = ((NI) 314159265);
	}
	LA3: ;
	nimln(144, "tables.nim");
	h = (NI)((*hc) & (t.data ? (t.data->Sup.len-1) : -1));
	{
		nimln(145, "tables.nim");
		while (1) {
			NIM_BOOL LOC7;
			if ((NU)(h) >= (NU)(t.data->Sup.len)) raiseIndexError();
			LOC7 = 0;
			LOC7 = isfilled_158211(t.data->data[h].Field0);
			if (!LOC7) goto LA6;
			nimln(150, "tables.nim");
			{
				NIM_BOOL LOC10;
				LOC10 = 0;
				if ((NU)(h) >= (NU)(t.data->Sup.len)) raiseIndexError();
				LOC10 = (t.data->data[h].Field0 == (*hc));
				if (!(LOC10)) goto LA11;
				if ((NU)(h) >= (NU)(t.data->Sup.len)) raiseIndexError();
				LOC10 = eqStrings(t.data->data[h].Field1, key);
				LA11: ;
				if (!LOC10) goto LA12;
				nimln(151, "tables.nim");
				result = h;
				goto BeforeRet;
			}
			LA12: ;
			nimln(152, "tables.nim");
			h = nexttry_158420(h, (t.data ? (t.data->Sup.len-1) : -1));
		} LA6: ;
	}
	nimln(153, "tables.nim");
	TMP1180 = subInt(((NI) -1), h);
	result = (NI)(TMP1180);
	}BeforeRet: ;
	popFrame();
	return result;
}

static N_INLINE(NI, rawgetknownhc_165726)(Table165376 t, NimStringDesc* key, NI hc) {
	NI result;
	NI h;
	NI TMP1187;
	nimfr("rawGetKnownHC", "tables.nim")
{	result = 0;
	nimln(144, "tables.nim");
	h = (NI)(hc & (t.data ? (t.data->Sup.len-1) : -1));
	{
		nimln(145, "tables.nim");
		while (1) {
			NIM_BOOL LOC3;
			if ((NU)(h) >= (NU)(t.data->Sup.len)) raiseIndexError();
			LOC3 = 0;
			LOC3 = isfilled_158211(t.data->data[h].Field0);
			if (!LOC3) goto LA2;
			nimln(150, "tables.nim");
			{
				NIM_BOOL LOC6;
				LOC6 = 0;
				if ((NU)(h) >= (NU)(t.data->Sup.len)) raiseIndexError();
				LOC6 = (t.data->data[h].Field0 == hc);
				if (!(LOC6)) goto LA7;
				if ((NU)(h) >= (NU)(t.data->Sup.len)) raiseIndexError();
				LOC6 = eqStrings(t.data->data[h].Field1, key);
				LA7: ;
				if (!LOC6) goto LA8;
				nimln(151, "tables.nim");
				result = h;
				goto BeforeRet;
			}
			LA8: ;
			nimln(152, "tables.nim");
			h = nexttry_158420(h, (t.data ? (t.data->Sup.len-1) : -1));
		} LA2: ;
	}
	nimln(153, "tables.nim");
	TMP1187 = subInt(((NI) -1), h);
	result = (NI)(TMP1187);
	}BeforeRet: ;
	popFrame();
	return result;
}

static N_INLINE(void, pushSafePoint)(TSafePoint* s) {
	(*s).hasRaiseAction = NIM_FALSE;
	(*s).prev = exchandler_17043;
	exchandler_17043 = s;
}

static N_INLINE(void, shallow_89424)(NimStringDesc** s_89427) {
	TGenericSeq* s;
	nimfr("shallow", "system.nim")
	nimln(3151, "system.nim");
	s = ((TGenericSeq*) ((*s_89427)));
	nimln(3152, "system.nim");
	(*s).reserved = (NI)((*s).reserved | ((NI) (IL64(-9223372036854775807) - IL64(1))));
	popFrame();
}

static N_INLINE(void, popSafePoint)(void) {
	exchandler_17043 = (*exchandler_17043).prev;
}

static N_INLINE(void, setFrame)(TFrame* s) {
	frameptr_17042 = s;
}

static N_INLINE(NIM_BOOL, canbecycleroot_50267)(Tcell46746* c) {
	NIM_BOOL result;
	nimfr("canBeCycleRoot", "gc.nim")
	result = 0;
	nimln(121, "gc.nim");
	result = !((((*(*c).typ).flags &(1<<((((NU8) 1))&7)))!=0));
	popFrame();
	return result;
}

static N_INLINE(void, rtladdcycleroot_51023)(Tcell46746* c) {
	nimfr("rtlAddCycleRoot", "gc.nim")
	nimln(189, "gc.nim");
	{
		if (!!((((NI) ((NI)((*c).refcount & ((NI) 3)))) == ((NI) 3)))) goto LA3;
		nimln(139, "gc.nim");
		(*c).refcount = (NI)((NI)((*c).refcount & ((NI) -4)) | ((NI) 3));
		nimln(191, "gc.nim");
		incl_47465((&gch_48644.cycleroots), c);
	}
	LA3: ;
	popFrame();
}

static N_INLINE(void, incref_52622)(Tcell46746* c) {
	nimfr("incRef", "gc.nim")
	nimln(216, "gc.nim");
	(*c).refcount = (NI)((NU64)((*c).refcount) + (NU64)(((NI) 8)));
	nimln(219, "gc.nim");
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = canbecycleroot_50267(c);
		if (!LOC3) goto LA4;
		nimln(220, "gc.nim");
		rtladdcycleroot_51023(c);
	}
	LA4: ;
	popFrame();
}

static N_INLINE(void, decref_52204)(Tcell46746* c) {
	nimfr("decRef", "gc.nim")
	nimln(206, "gc.nim");
	{
		nimln(167, "gc.nim");
		(*c).refcount -= ((NI) 8);
		nimln(168, "gc.nim");
		if (!((NU64)((*c).refcount) < (NU64)(((NI) 8)))) goto LA3;
		nimln(207, "gc.nim");
		rtladdzct_51804(c);
	}
	goto LA1;
	LA3: ;
	{
		NIM_BOOL LOC6;
		nimln(208, "gc.nim");
		LOC6 = 0;
		LOC6 = canbecycleroot_50267(c);
		if (!LOC6) goto LA7;
		nimln(211, "gc.nim");
		rtladdcycleroot_51023(c);
	}
	goto LA1;
	LA7: ;
	LA1: ;
	popFrame();
}

static N_INLINE(void, asgnRef)(void** dest, void* src) {
	nimfr("asgnRef", "gc.nim")
	nimln(244, "gc.nim");
	{
		Tcell46746* LOC5;
		if (!!((src == NIM_NIL))) goto LA3;
		LOC5 = 0;
		LOC5 = usrtocell_50246(src);
		incref_52622(LOC5);
	}
	LA3: ;
	nimln(245, "gc.nim");
	{
		Tcell46746* LOC10;
		if (!!(((*dest) == NIM_NIL))) goto LA8;
		LOC10 = 0;
		LOC10 = usrtocell_50246((*dest));
		decref_52204(LOC10);
	}
	LA8: ;
	nimln(246, "gc.nim");
	(*dest) = src;
	popFrame();
}

static N_INLINE(void, popCurrentException)(void) {
	asgnRef((void**) (&currexception_17045), (*currexception_17045).parent);
}

N_NIMCALL(NI32, fileinfoidx_165533)(NimStringDesc* filename, NIM_BOOL* isknownfile) {
	NI32 result;
	NimStringDesc* volatile canon;
	NIM_BOOL pseudopath;
	TSafePoint TMP1188;
	nimfr("fileInfoIdx", "msgs.nim")
	result = 0;
	canon = 0;
	nimln(526, "msgs.nim");
	pseudopath = NIM_FALSE;
	nimln(528, "msgs.nim");
	pushSafePoint(&TMP1188);
	TMP1188.status = setjmp(TMP1188.context);
	if (TMP1188.status == 0) {
		nimln(529, "msgs.nim");
		canon = canonicalizepath_156374(filename);
		nimln(530, "msgs.nim");
		shallow_89424((&canon));
		popSafePoint();
	}
	else {
		popSafePoint();
		setFrame((TFrame*)&FR);
		{
			TMP1188.status = 0;
			nimln(532, "msgs.nim");
			canon = copyString(filename);
			nimln(535, "msgs.nim");
			pseudopath = NIM_TRUE;
			popCurrentException();
		}
	}
	if (TMP1188.status != 0) reraiseException();
	nimln(537, "msgs.nim");
	{
		NIM_BOOL LOC6;
		LOC6 = 0;
		LOC6 = haskey_165543(filenametoindextbl_165414, canon);
		if (!LOC6) goto LA7;
		nimln(538, "msgs.nim");
		result = HEX5BHEX5D_165586(filenametoindextbl_165414, canon);
	}
	goto LA4;
	LA7: ;
	{
		NimStringDesc* LOC10;
		Tfileinfo165336 LOC16;
		nimln(540, "msgs.nim");
		(*isknownfile) = NIM_FALSE;
		nimln(541, "msgs.nim");
		result = ((NI32)chckRange((fileinfos_165432 ? fileinfos_165432->Sup.len : 0), ((NI32) (-2147483647 -1)), ((NI32) 2147483647)));
		nimln(542, "msgs.nim");
		LOC10 = 0;
		{
			if (!pseudopath) goto LA13;
			LOC10 = copyString(filename);
		}
		goto LA11;
		LA13: ;
		{
			nimln(543, "msgs.nim");
			LOC10 = shortendir_156407(canon);
		}
		LA11: ;
		memset((void*)(&LOC16), 0, sizeof(LOC16));
		newfileinfo_165495(canon, LOC10, (&LOC16));
		fileinfos_165432 = (TY165415*) incrSeq(&(fileinfos_165432)->Sup, sizeof(Tfileinfo165336));
		genericAssign((void*)(&fileinfos_165432->data[fileinfos_165432->Sup.len-1]), (void*)(&LOC16), (&NTI165336));
		nimln(544, "msgs.nim");
		HEX5BHEX5DHEX3D_165635((&filenametoindextbl_165414), canon, result);
	}
	LA4: ;
	popFrame();
	return result;
}

N_NIMCALL(NI32, fileinfoidx_165853)(NimStringDesc* filename) {
	NI32 result;
	NIM_BOOL dummy;
	nimfr("fileInfoIdx", "msgs.nim")
	result = 0;
	dummy = 0;
	nimln(548, "msgs.nim");
	result = fileinfoidx_165533(filename, (&dummy));
	popFrame();
	return result;
}

N_NIMCALL(Tlineinfo165338, newlineinfo_165866)(NI32 fileinfoidx, NI line, NI col) {
	Tlineinfo165338 result;
	nimfr("newLineInfo", "msgs.nim")
	memset((void*)(&result), 0, sizeof(result));
	nimln(551, "msgs.nim");
	result.fileindex = fileinfoidx;
	nimln(552, "msgs.nim");
	result.line = ((NI16)chckRange(line, ((NI16) -32768), ((NI16) 32767)));
	nimln(553, "msgs.nim");
	result.col = ((NI16)chckRange(col, ((NI16) -32768), ((NI16) 32767)));
	popFrame();
	return result;
}

static N_INLINE(Tlineinfo165338, newlineinfo_165878)(NimStringDesc* filename, NI line, NI col) {
	Tlineinfo165338 result;
	NI32 LOC1;
	nimfr("newLineInfo", "msgs.nim")
	memset((void*)(&result), 0, sizeof(result));
	nimln(556, "msgs.nim");
	LOC1 = 0;
	LOC1 = fileinfoidx_165853(filename);
	result = newlineinfo_165866(LOC1, line, col);
	popFrame();
	return result;
}
N_NIMCALL(void, TMP1191)(void* p, NI op) {
	Erecoverableerror165344* a;
	a = (Erecoverableerror165344*)p;
	nimGCvisit((void*)(*a).Sup.Sup.parent, op);
	nimGCvisit((void*)(*a).Sup.Sup.message, op);
	nimGCvisit((void*)(*a).Sup.Sup.trace, op);
}

N_NOINLINE(void, raiserecoverableerror_165966)(NimStringDesc* msg) {
	Erecoverableerror165344* e_165971;
	NimStringDesc* LOC1;
	nimfr("raiseRecoverableError", "msgs.nim")
	e_165971 = 0;
	nimln(2265, "system.nim");
	e_165971 = (Erecoverableerror165344*) newObj((&NTI165972), sizeof(Erecoverableerror165344));
	(*e_165971).Sup.Sup.Sup.m_type = (&NTI165344);
	nimln(2266, "system.nim");
	LOC1 = 0;
	LOC1 = (*e_165971).Sup.Sup.message; (*e_165971).Sup.Sup.message = copyStringRC1(msg);
	if (LOC1) nimGCunrefNoCycle(LOC1);
	nimln(565, "msgs.nim");
	raiseException((Exception*)e_165971, "ERecoverableError");
	popFrame();
}

N_NIMCALL(Tlineinfo165338, unknownlineinfo_166024)(void) {
	Tlineinfo165338 result;
	nimfr("unknownLineInfo", "msgs.nim")
	memset((void*)(&result), 0, sizeof(result));
	nimln(579, "msgs.nim");
	result.line = ((NI16) -1);
	nimln(580, "msgs.nim");
	result.col = ((NI16) -1);
	nimln(581, "msgs.nim");
	result.fileindex = ((NI32) -1);
	popFrame();
	return result;
}
N_NIMCALL(void, TMP1193)(void* p, NI op) {
	TY166033* a;
	NI LOC1;
	a = (TY166033*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	}
}

static N_INLINE(void, writeln_157205)(FILE* f, NimStringDesc** x, NI xLen0) {
	nimfr("writeln", "sysio.nim")
	{
		NimStringDesc* i_157221;
		NI i_157229;
		i_157221 = 0;
		nimln(1689, "system.nim");
		i_157229 = ((NI) 0);
		{
			nimln(1690, "system.nim");
			while (1) {
				if (!(i_157229 < xLen0)) goto LA3;
				nimln(1691, "system.nim");
				i_157221 = x[i_157229];
				nimln(212, "sysio.nim");
				write_13457(f, i_157221);
				nimln(1692, "system.nim");
				i_157229 += ((NI) 1);
			} LA3: ;
		}
	}
	nimln(213, "sysio.nim");
	write_13457(f, ((NimStringDesc*) &TMP1194));
	popFrame();
}

N_NIMCALL(void, suggestwriteln_166066)(NimStringDesc* s) {
	nimfr("suggestWriteln", "msgs.nim")
	nimln(591, "msgs.nim");
	{
		if (!((erroroutputs_166053 &(1<<((((NU8) 0))&7)))!=0)) goto LA3;
		nimln(592, "msgs.nim");
		{
			TY157201 LOC9;
			if (!writelnhook_166057.ClPrc == 0) goto LA7;
			memset((void*)LOC9, 0, sizeof(LOC9));
			LOC9[0] = copyString(s);
			writeln_157205(stdout, LOC9, 1);
		}
		goto LA5;
		LA7: ;
		{
			nimln(593, "msgs.nim");
			writelnhook_166057.ClEnv? writelnhook_166057.ClPrc(s, writelnhook_166057.ClEnv):((TMP1195)(writelnhook_166057.ClPrc))(s);
		}
		LA5: ;
	}
	LA3: ;
	popFrame();
}

N_NIMCALL(void, msgquit_166104)(NI8 x) {
	nimfr("msgQuit", "msgs.nim")
	nimln(595, "msgs.nim");
	exit(((NI) (x)));
	popFrame();
}

N_NIMCALL(void, msgquit_166113)(NimStringDesc* x) {
	nimfr("msgQuit", "msgs.nim")
	nimln(596, "msgs.nim");
	quit_87981(x, ((NI) 1));
	popFrame();
}
N_NIMCALL(void, TMP1196)(void* p, NI op) {
	Esuggestdone165346* a;
	a = (Esuggestdone165346*)p;
	nimGCvisit((void*)(*a).Sup.parent, op);
	nimGCvisit((void*)(*a).Sup.message, op);
	nimGCvisit((void*)(*a).Sup.trace, op);
}

N_NIMCALL(void, suggestquit_166122)(void) {
	Esuggestdone165346* e_166126;
	NimStringDesc* LOC1;
	nimfr("suggestQuit", "msgs.nim")
	e_166126 = 0;
	nimln(2265, "system.nim");
	e_166126 = (Esuggestdone165346*) newObj((&NTI166127), sizeof(Esuggestdone165346));
	(*e_166126).Sup.Sup.m_type = (&NTI165346);
	nimln(2266, "system.nim");
	LOC1 = 0;
	LOC1 = (*e_166126).Sup.message; (*e_166126).Sup.message = copyStringRC1(((NimStringDesc*) &TMP1197));
	if (LOC1) nimGCunrefNoCycle(LOC1);
	nimln(599, "msgs.nim");
	raiseException((Exception*)e_166126, "ESuggestDone");
	popFrame();
}

N_NIMCALL(NI, getinfocontextlen_166153)(void) {
	NI result;
	nimfr("getInfoContextLen", "msgs.nim")
{	result = 0;
	nimln(612, "msgs.nim");
	result = (msgcontext_166050 ? msgcontext_166050->Sup.len : 0);
	goto BeforeRet;
	}BeforeRet: ;
	popFrame();
	return result;
}

N_NIMCALL(void, setinfocontextlen_166170)(NI L) {
	nimfr("setInfoContextLen", "msgs.nim")
	nimln(613, "msgs.nim");
	msgcontext_166050 = (TY166033*) setLengthSeq(&(msgcontext_166050)->Sup, sizeof(Tlineinfo165338), ((NI)chckRange(L, ((NI) 0), ((NI) IL64(9223372036854775807)))));
	popFrame();
}

N_NIMCALL(void, pushinfocontext_166189)(Tlineinfo165338 info) {
	nimfr("pushInfoContext", "msgs.nim")
	nimln(616, "msgs.nim");
	msgcontext_166050 = (TY166033*) incrSeq(&(msgcontext_166050)->Sup, sizeof(Tlineinfo165338));
	msgcontext_166050->data[msgcontext_166050->Sup.len-1] = info;
	popFrame();
}

N_NIMCALL(void, popinfocontext_166208)(void) {
	NI TMP1198;
	nimfr("popInfoContext", "msgs.nim")
	nimln(619, "msgs.nim");
	TMP1198 = subInt((msgcontext_166050 ? msgcontext_166050->Sup.len : 0), ((NI) 1));
	msgcontext_166050 = (TY166033*) setLengthSeq(&(msgcontext_166050)->Sup, sizeof(Tlineinfo165338), ((NI)chckRange((NI)(TMP1198), ((NI) 0), ((NI) IL64(9223372036854775807)))));
	popFrame();
}

N_NIMCALL(Tlineinfo165338, getinfocontext_166234)(NI index) {
	Tlineinfo165338 result;
	NI L;
	NI i;
	nimfr("getInfoContext", "msgs.nim")
	memset((void*)(&result), 0, sizeof(result));
	nimln(622, "msgs.nim");
	L = (msgcontext_166050 ? msgcontext_166050->Sup.len : 0);
	nimln(623, "msgs.nim");
	{
		NI TMP1199;
		if (!(index < ((NI) 0))) goto LA3;
		TMP1199 = addInt(L, index);
		i = (NI)(TMP1199);
	}
	goto LA1;
	LA3: ;
	{
		i = index;
	}
	LA1: ;
	nimln(624, "msgs.nim");
	{
		if (!((NU64)(L) <= (NU64)(i))) goto LA8;
		result = unknownlineinfo_166024();
	}
	goto LA6;
	LA8: ;
	{
		nimln(625, "msgs.nim");
		if ((NU)(i) >= (NU)(msgcontext_166050->Sup.len)) raiseIndexError();
		result = msgcontext_166050->data[i];
	}
	LA6: ;
	popFrame();
	return result;
}

N_NIMCALL(NimStringDesc*, tofilename_166263)(NI32 fileidx) {
	NimStringDesc* result;
	nimfr("toFilename", "msgs.nim")
	result = 0;
	nimln(628, "msgs.nim");
	{
		if (!(fileidx < ((NI32) 0))) goto LA3;
		result = copyString(((NimStringDesc*) &TMP1200));
	}
	goto LA1;
	LA3: ;
	{
		nimln(629, "msgs.nim");
		if ((NU)(fileidx) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
		result = copyString(fileinfos_165432->data[fileidx].projpath);
	}
	LA1: ;
	popFrame();
	return result;
}

N_NIMCALL(NimStringDesc*, tofullpath_166273)(NI32 fileidx) {
	NimStringDesc* result;
	nimfr("toFullPath", "msgs.nim")
	result = 0;
	nimln(632, "msgs.nim");
	{
		if (!(fileidx < ((NI32) 0))) goto LA3;
		result = copyString(((NimStringDesc*) &TMP1200));
	}
	goto LA1;
	LA3: ;
	{
		nimln(633, "msgs.nim");
		if ((NU)(fileidx) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
		result = copyString(fileinfos_165432->data[fileidx].fullpath);
	}
	LA1: ;
	popFrame();
	return result;
}

N_NIMCALL(void, setdirtyfile_166283)(NI32 fileidx, NimStringDesc* filename) {
	NimStringDesc* LOC5;
	nimfr("setDirtyFile", "msgs.nim")
	nimln(636, "msgs.nim");
	{
		if (!!((((NI32) 0) <= fileidx))) goto LA3;
		failedassertimpl_88817(((NimStringDesc*) &TMP1201));
	}
	LA3: ;
	nimln(637, "msgs.nim");
	if ((NU)(fileidx) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
	LOC5 = 0;
	LOC5 = fileinfos_165432->data[fileidx].dirtyfile; fileinfos_165432->data[fileidx].dirtyfile = copyStringRC1(filename);
	if (LOC5) nimGCunrefNoCycle(LOC5);
	popFrame();
}

N_NIMCALL(NimStringDesc*, tofullpathconsiderdirty_166407)(NI32 fileidx) {
	NimStringDesc* result;
	nimfr("toFullPathConsiderDirty", "msgs.nim")
	result = 0;
	nimln(640, "msgs.nim");
	{
		if (!(fileidx < ((NI32) 0))) goto LA3;
		nimln(641, "msgs.nim");
		result = copyString(((NimStringDesc*) &TMP1200));
	}
	goto LA1;
	LA3: ;
	{
		nimln(642, "msgs.nim");
		if ((NU)(fileidx) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
		if (!!(fileinfos_165432->data[fileidx].dirtyfile == 0)) goto LA6;
		nimln(643, "msgs.nim");
		if ((NU)(fileidx) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
		result = copyString(fileinfos_165432->data[fileidx].dirtyfile);
	}
	goto LA1;
	LA6: ;
	{
		nimln(645, "msgs.nim");
		if ((NU)(fileidx) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
		result = copyString(fileinfos_165432->data[fileidx].fullpath);
	}
	LA1: ;
	popFrame();
	return result;
}

N_NIMCALL(NimStringDesc*, tomsgfilename_166429)(Tlineinfo165338 info) {
	NimStringDesc* result;
	nimfr("toMsgFilename", "msgs.nim")
	result = 0;
	nimln(654, "msgs.nim");
	{
		if (!(info.fileindex < ((NI32) 0))) goto LA3;
		nimln(655, "msgs.nim");
		result = copyString(((NimStringDesc*) &TMP1200));
	}
	goto LA1;
	LA3: ;
	{
		if (!glistfullpaths_156142) goto LA6;
		nimln(657, "msgs.nim");
		if ((NU)(info.fileindex) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
		result = copyString(fileinfos_165432->data[info.fileindex].fullpath);
	}
	goto LA1;
	LA6: ;
	{
		nimln(659, "msgs.nim");
		if ((NU)(info.fileindex) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
		result = copyString(fileinfos_165432->data[info.fileindex].projpath);
	}
	LA1: ;
	popFrame();
	return result;
}

static N_INLINE(NI, tolinenumber_166439)(Tlineinfo165338 info) {
	NI result;
	nimfr("toLinenumber", "msgs.nim")
	result = 0;
	nimln(662, "msgs.nim");
	result = ((NI) (info.line));
	popFrame();
	return result;
}

static N_INLINE(NI, tocolumn_166449)(Tlineinfo165338 info) {
	NI result;
	nimfr("toColumn", "msgs.nim")
	result = 0;
	nimln(665, "msgs.nim");
	result = ((NI) (info.col));
	popFrame();
	return result;
}

static N_INLINE(NimStringDesc*, tofileline_166459)(Tlineinfo165338 info) {
	NimStringDesc* result;
	NimStringDesc* LOC1;
	NimStringDesc* LOC2;
	NimStringDesc* LOC3;
	nimfr("toFileLine", "msgs.nim")
	result = 0;
	nimln(668, "msgs.nim");
	LOC1 = 0;
	LOC2 = 0;
	LOC2 = tofilename_166263(info.fileindex);
	LOC3 = 0;
	LOC3 = nimIntToStr(((NI) (info.line)));
	LOC1 = rawNewString(LOC2->Sup.len + LOC3->Sup.len + 1);
appendString(LOC1, LOC2);
appendString(LOC1, ((NimStringDesc*) &TMP1202));
appendString(LOC1, LOC3);
	result = LOC1;
	popFrame();
	return result;
}

static N_INLINE(NimStringDesc*, tofilelinecol_166469)(Tlineinfo165338 info) {
	NimStringDesc* result;
	NimStringDesc* LOC1;
	NimStringDesc* LOC2;
	NimStringDesc* LOC3;
	NimStringDesc* LOC4;
	nimfr("toFileLineCol", "msgs.nim")
	result = 0;
	nimln(671, "msgs.nim");
	LOC1 = 0;
	LOC2 = 0;
	LOC2 = tofilename_166263(info.fileindex);
	LOC3 = 0;
	LOC3 = nimIntToStr(((NI) (info.line)));
	LOC4 = 0;
	LOC4 = nimIntToStr(((NI) (info.col)));
	LOC1 = rawNewString(LOC2->Sup.len + LOC3->Sup.len + LOC4->Sup.len + 3);
appendString(LOC1, LOC2);
appendString(LOC1, ((NimStringDesc*) &TMP1203));
appendString(LOC1, LOC3);
appendString(LOC1, ((NimStringDesc*) &TMP1204));
appendString(LOC1, LOC4);
appendString(LOC1, ((NimStringDesc*) &TMP1205));
	result = LOC1;
	popFrame();
	return result;
}

N_NIMCALL(NimStringDesc*, HEX24_166479)(Tlineinfo165338 info) {
	NimStringDesc* result;
	nimfr("$", "msgs.nim")
	result = 0;
	nimln(673, "msgs.nim");
	result = tofilelinecol_166469(info);
	popFrame();
	return result;
}

N_NIMCALL(NIM_BOOL, HEX3FHEX3F_166489)(Tlineinfo165338 info, NimStringDesc* filename) {
	NIM_BOOL result;
	NimStringDesc* LOC1;
	nimfr("??", "msgs.nim")
	result = 0;
	nimln(677, "msgs.nim");
	LOC1 = 0;
	LOC1 = tofilename_166263(info.fileindex);
	result = contains_101362(LOC1, filename);
	popFrame();
	return result;
}

N_NIMCALL(void, outwriteln_166505)(NimStringDesc* s) {
	nimfr("outWriteln", "msgs.nim")
	nimln(683, "msgs.nim");
	{
		TY157201 LOC5;
		if (!((erroroutputs_166053 &(1<<((((NU8) 0))&7)))!=0)) goto LA3;
		memset((void*)LOC5, 0, sizeof(LOC5));
		LOC5[0] = copyString(s);
		writeln_157205(stdout, LOC5, 1);
	}
	LA3: ;
	popFrame();
}

N_NIMCALL(void, msgwriteln_166536)(NimStringDesc* s) {
	nimfr("msgWriteln", "msgs.nim")
	nimln(690, "msgs.nim");
	{
		if (!!(writelnhook_166057.ClPrc == 0)) goto LA3;
		nimln(691, "msgs.nim");
		writelnhook_166057.ClEnv? writelnhook_166057.ClPrc(s, writelnhook_166057.ClEnv):((TMP1206)(writelnhook_166057.ClPrc))(s);
	}
	goto LA1;
	LA3: ;
	{
		nimln(692, "msgs.nim");
		if (!((gglobaloptions_156128 &(1<<((((NU8) 22))&31)))!=0)) goto LA6;
		nimln(693, "msgs.nim");
		{
			TY157201 LOC12;
			if (!((erroroutputs_166053 &(1<<((((NU8) 1))&7)))!=0)) goto LA10;
			memset((void*)LOC12, 0, sizeof(LOC12));
			LOC12[0] = copyString(s);
			writeln_157205(stderr, LOC12, 1);
		}
		LA10: ;
	}
	goto LA1;
	LA6: ;
	{
		nimln(695, "msgs.nim");
		{
			TY157201 LOC18;
			if (!((erroroutputs_166053 &(1<<((((NU8) 0))&7)))!=0)) goto LA16;
			memset((void*)LOC18, 0, sizeof(LOC18));
			LOC18[0] = copyString(s);
			writeln_157205(stdout, LOC18, 1);
		}
		LA16: ;
	}
	LA1: ;
	popFrame();
}

N_NIMCALL(NimStringDesc*, coordtostr_166606)(NI coord) {
	NimStringDesc* result;
	nimfr("coordToStr", "msgs.nim")
	result = 0;
	nimln(698, "msgs.nim");
	{
		if (!(coord == ((NI) -1))) goto LA3;
		result = copyString(((NimStringDesc*) &TMP1200));
	}
	goto LA1;
	LA3: ;
	{
		nimln(699, "msgs.nim");
		result = nimIntToStr(coord);
	}
	LA1: ;
	popFrame();
	return result;
}

N_NIMCALL(NimStringDesc*, msgkindtostring_166616)(NU16 kind) {
	NimStringDesc* result;
	nimfr("msgKindToString", "msgs.nim")
	result = 0;
	nimln(703, "msgs.nim");
	result = copyString(Msgkindtostr_165287[(kind)- 0]);
	popFrame();
	return result;
}

N_NIMCALL(NimStringDesc*, getmessagestr_166626)(NU16 msg, NimStringDesc* arg) {
	NimStringDesc* result;
	NimStringDesc* LOC1;
	TY157201 LOC2;
	nimfr("getMessageStr", "msgs.nim")
	result = 0;
	nimln(706, "msgs.nim");
	LOC1 = 0;
	LOC1 = msgkindtostring_166616(msg);
	memset((void*)LOC2, 0, sizeof(LOC2));
	LOC2[0] = copyString(arg);
	result = nsuFormatOpenArray(LOC1, LOC2, 1);
	popFrame();
	return result;
}

N_NIMCALL(void, handleerror_166647)(NU16 msg, NU8 eh, NimStringDesc* s) {
	nimfr("handleError", "msgs.nim")
	nimln(720, "msgs.nim");
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (((NU16) 0) <= msg);
		if (!(LOC3)) goto LA4;
		LOC3 = (msg <= ((NU16) 2));
		LA4: ;
		if (!LOC3) goto LA5;
		nimln(713, "msgs.nim");
		{
			NIM_BOOL LOC9;
			NIM_BOOL LOC10;
			LOC9 = 0;
			LOC10 = 0;
			LOC10 = NIM_FALSE;
			if (LOC10) goto LA11;
			LOC10 = (((NI) 3) <= gverbosity_156137);
			LA11: ;
			LOC9 = LOC10;
			if (LOC9) goto LA12;
			LOC9 = (msg == ((NU16) 2));
			LA12: ;
			if (!LOC9) goto LA13;
			nimln(714, "msgs.nim");
			{
				NIM_BOOL LOC17;
				LOC17 = 0;
				LOC17 = stacktraceavailable_17930();
				if (!(LOC17)) goto LA18;
				LOC17 = writelnhook_166057.ClPrc == 0;
				LA18: ;
				if (!LOC17) goto LA19;
				nimln(715, "msgs.nim");
				writestacktrace_16407();
			}
			goto LA15;
			LA19: ;
			{
				NimStringDesc* LOC22;
				nimln(717, "msgs.nim");
				LOC22 = 0;
				LOC22 = rawNewString(command_156239->Sup.len + 96);
appendString(LOC22, ((NimStringDesc*) &TMP1234));
appendString(LOC22, command_156239);
appendString(LOC22, ((NimStringDesc*) &TMP1235));
				msgwriteln_166536(LOC22);
			}
			LA15: ;
		}
		LA13: ;
		nimln(718, "msgs.nim");
		exit(((NI) 1));
	}
	LA5: ;
	nimln(722, "msgs.nim");
	{
		NIM_BOOL LOC25;
		NI TMP1236;
		LOC25 = 0;
		LOC25 = (((NU16) 0) <= msg);
		if (!(LOC25)) goto LA26;
		LOC25 = (msg <= ((NU16) 229));
		LA26: ;
		if (!LOC25) goto LA27;
		nimln(723, "msgs.nim");
		TMP1236 = addInt(gerrorcounter_166012, ((NI) 1));
		gerrorcounter_166012 = (NI)(TMP1236);
		nimln(724, "msgs.nim");
		gexitcode_156129 = ((NI8) 1);
		nimln(725, "msgs.nim");
		{
			if (!(gerrormax_166015 <= gerrorcounter_166012)) goto LA31;
			nimln(713, "msgs.nim");
			{
				NIM_BOOL LOC35;
				NIM_BOOL LOC36;
				LOC35 = 0;
				LOC36 = 0;
				LOC36 = NIM_FALSE;
				if (LOC36) goto LA37;
				LOC36 = (((NI) 3) <= gverbosity_156137);
				LA37: ;
				LOC35 = LOC36;
				if (LOC35) goto LA38;
				LOC35 = (msg == ((NU16) 2));
				LA38: ;
				if (!LOC35) goto LA39;
				nimln(714, "msgs.nim");
				{
					NIM_BOOL LOC43;
					LOC43 = 0;
					LOC43 = stacktraceavailable_17930();
					if (!(LOC43)) goto LA44;
					LOC43 = writelnhook_166057.ClPrc == 0;
					LA44: ;
					if (!LOC43) goto LA45;
					nimln(715, "msgs.nim");
					writestacktrace_16407();
				}
				goto LA41;
				LA45: ;
				{
					NimStringDesc* LOC48;
					nimln(717, "msgs.nim");
					LOC48 = 0;
					LOC48 = rawNewString(command_156239->Sup.len + 96);
appendString(LOC48, ((NimStringDesc*) &TMP1234));
appendString(LOC48, command_156239);
appendString(LOC48, ((NimStringDesc*) &TMP1235));
					msgwriteln_166536(LOC48);
				}
				LA41: ;
			}
			LA39: ;
			nimln(718, "msgs.nim");
			exit(((NI) 1));
		}
		goto LA29;
		LA31: ;
		{
			NIM_BOOL LOC50;
			nimln(727, "msgs.nim");
			LOC50 = 0;
			LOC50 = (eh == ((NU8) 1));
			if (!(LOC50)) goto LA51;
			LOC50 = !((gcmd_156130 == ((NU8) 14)));
			LA51: ;
			if (!LOC50) goto LA52;
			nimln(713, "msgs.nim");
			{
				NIM_BOOL LOC56;
				NIM_BOOL LOC57;
				LOC56 = 0;
				LOC57 = 0;
				LOC57 = NIM_FALSE;
				if (LOC57) goto LA58;
				LOC57 = (((NI) 3) <= gverbosity_156137);
				LA58: ;
				LOC56 = LOC57;
				if (LOC56) goto LA59;
				LOC56 = (msg == ((NU16) 2));
				LA59: ;
				if (!LOC56) goto LA60;
				nimln(714, "msgs.nim");
				{
					NIM_BOOL LOC64;
					LOC64 = 0;
					LOC64 = stacktraceavailable_17930();
					if (!(LOC64)) goto LA65;
					LOC64 = writelnhook_166057.ClPrc == 0;
					LA65: ;
					if (!LOC64) goto LA66;
					nimln(715, "msgs.nim");
					writestacktrace_16407();
				}
				goto LA62;
				LA66: ;
				{
					NimStringDesc* LOC69;
					nimln(717, "msgs.nim");
					LOC69 = 0;
					LOC69 = rawNewString(command_156239->Sup.len + 96);
appendString(LOC69, ((NimStringDesc*) &TMP1234));
appendString(LOC69, command_156239);
appendString(LOC69, ((NimStringDesc*) &TMP1235));
					msgwriteln_166536(LOC69);
				}
				LA62: ;
			}
			LA60: ;
			nimln(718, "msgs.nim");
			exit(((NI) 1));
		}
		goto LA29;
		LA52: ;
		{
			nimln(729, "msgs.nim");
			if (!(eh == ((NU8) 2))) goto LA71;
			nimln(730, "msgs.nim");
			raiserecoverableerror_165966(s);
		}
		goto LA29;
		LA71: ;
		LA29: ;
	}
	LA27: ;
	popFrame();
}

N_NIMCALL(NIM_BOOL, HEX3DHEX3D_166789)(Tlineinfo165338 a, Tlineinfo165338 b) {
	NIM_BOOL result;
	NIM_BOOL LOC1;
	nimfr("==", "msgs.nim")
	result = 0;
	nimln(733, "msgs.nim");
	LOC1 = 0;
	LOC1 = (a.line == b.line);
	if (!(LOC1)) goto LA2;
	LOC1 = (a.fileindex == b.fileindex);
	LA2: ;
	result = LOC1;
	popFrame();
	return result;
}

N_NIMCALL(void, writecontext_166800)(Tlineinfo165338 lastinfo) {
	Tlineinfo165338 info;
	nimfr("writeContext", "msgs.nim")
	nimln(736, "msgs.nim");
	info = lastinfo;
	{
		NI i_166824;
		NI HEX3Atmp_166828;
		NI TMP1237;
		NI res_166831;
		i_166824 = 0;
		HEX3Atmp_166828 = 0;
		nimln(737, "msgs.nim");
		TMP1237 = subInt((msgcontext_166050 ? msgcontext_166050->Sup.len : 0), ((NI) 1));
		HEX3Atmp_166828 = (NI)(TMP1237);
		nimln(1598, "system.nim");
		res_166831 = ((NI) 0);
		{
			nimln(1599, "system.nim");
			while (1) {
				NI TMP1240;
				if (!(res_166831 <= HEX3Atmp_166828)) goto LA3;
				nimln(1600, "system.nim");
				i_166824 = res_166831;
				nimln(738, "msgs.nim");
				{
					NIM_BOOL LOC6;
					NIM_BOOL LOC7;
					NIM_BOOL LOC9;
					TY166825 LOC12;
					NI TMP1239;
					NimStringDesc* LOC13;
					LOC6 = 0;
					if ((NU)(i_166824) >= (NU)(msgcontext_166050->Sup.len)) raiseIndexError();
					LOC7 = 0;
					LOC7 = HEX3DHEX3D_166789(msgcontext_166050->data[i_166824], lastinfo);
					LOC6 = !(LOC7);
					if (!(LOC6)) goto LA8;
					if ((NU)(i_166824) >= (NU)(msgcontext_166050->Sup.len)) raiseIndexError();
					LOC9 = 0;
					LOC9 = HEX3DHEX3D_166789(msgcontext_166050->data[i_166824], info);
					LOC6 = !(LOC9);
					LA8: ;
					if (!LOC6) goto LA10;
					nimln(739, "msgs.nim");
					memset((void*)LOC12, 0, sizeof(LOC12));
					if ((NU)(i_166824) >= (NU)(msgcontext_166050->Sup.len)) raiseIndexError();
					LOC12[0] = tomsgfilename_166429(msgcontext_166050->data[i_166824]);
					nimln(740, "msgs.nim");
					if ((NU)(i_166824) >= (NU)(msgcontext_166050->Sup.len)) raiseIndexError();
					LOC12[1] = coordtostr_166606(((NI) (msgcontext_166050->data[i_166824].line)));
					nimln(741, "msgs.nim");
					if ((NU)(i_166824) >= (NU)(msgcontext_166050->Sup.len)) raiseIndexError();
					TMP1239 = addInt(msgcontext_166050->data[i_166824].col, ((NI16) 1));
					if (TMP1239 < -32768 || TMP1239 > 32767) raiseOverflow();
					LOC12[2] = coordtostr_166606(((NI) ((NI16)(TMP1239))));
					nimln(742, "msgs.nim");
					LOC12[3] = getmessagestr_166626(((NU16) 184), ((NimStringDesc*) &TMP1177));
					LOC13 = 0;
					LOC13 = nsuFormatOpenArray(((NimStringDesc*) &TMP1238), LOC12, 4);
					msgwriteln_166536(LOC13);
				}
				LA10: ;
				nimln(743, "msgs.nim");
				if ((NU)(i_166824) >= (NU)(msgcontext_166050->Sup.len)) raiseIndexError();
				info = msgcontext_166050->data[i_166824];
				nimln(1614, "system.nim");
				TMP1240 = addInt(res_166831, ((NI) 1));
				res_166831 = (NI)(TMP1240);
			} LA3: ;
		}
	}
	popFrame();
}

N_NIMCALL(NIM_BOOL, ignoremsgbecauseofidetools_166850)(NU16 msg) {
	NIM_BOOL result;
	NIM_BOOL LOC1;
	NIM_BOOL LOC2;
	nimfr("ignoreMsgBecauseOfIdeTools", "msgs.nim")
	result = 0;
	nimln(746, "msgs.nim");
	LOC1 = 0;
	LOC2 = 0;
	LOC2 = (((NU16) 4) <= msg);
	if (!(LOC2)) goto LA3;
	LOC2 = (gcmd_156130 == ((NU8) 14));
	LA3: ;
	LOC1 = LOC2;
	if (!(LOC1)) goto LA4;
	LOC1 = !(((gglobaloptions_156128 &(1<<((((NU8) 28))&31)))!=0));
	LA4: ;
	result = LOC1;
	popFrame();
	return result;
}

N_NIMCALL(void, rawmessage_166888)(NU16 msg, NimStringDesc** args, NI argsLen0) {
	NimStringDesc* frmt;
	NimStringDesc* s;
	NimStringDesc* LOC22;
	NimStringDesc* LOC23;
	nimfr("rawMessage", "msgs.nim")
{	frmt = 0;
	nimln(750, "msgs.nim");
	switch (msg) {
	case ((NU16) 0) ... ((NU16) 229):
	{
		Tlineinfo165338 LOC2;
		nimln(752, "msgs.nim");
		LOC2 = unknownlineinfo_166024();
		writecontext_166800(LOC2);
		nimln(753, "msgs.nim");
		frmt = copyString(((NimStringDesc*) &TMP1241));
	}
	break;
	case ((NU16) 230) ... ((NU16) 260):
	{
		Tlineinfo165338 LOC12;
		NI TMP1243;
		nimln(755, "msgs.nim");
		{
			if (!!(((goptions_156126 &(1<<((((NU8) 11))&31)))!=0))) goto LA6;
			goto BeforeRet;
		}
		LA6: ;
		nimln(756, "msgs.nim");
		{
			if (!!(((gnotes_166011 &(IL64(1)<<(((((NU16)chckRange(msg, ((NU16) 230), ((NU16) 277)))- 230))&IL64(63))))!=0))) goto LA10;
			goto BeforeRet;
		}
		LA10: ;
		nimln(757, "msgs.nim");
		LOC12 = unknownlineinfo_166024();
		writecontext_166800(LOC12);
		nimln(758, "msgs.nim");
		frmt = copyString(((NimStringDesc*) &TMP1242));
		nimln(759, "msgs.nim");
		TMP1243 = addInt(gwarncounter_166014, ((NI) 1));
		gwarncounter_166014 = (NI)(TMP1243);
	}
	break;
	case ((NU16) 261) ... ((NU16) 277):
	{
		NI TMP1245;
		nimln(761, "msgs.nim");
		{
			if (!!(((goptions_156126 &(1<<((((NU8) 12))&31)))!=0))) goto LA16;
			goto BeforeRet;
		}
		LA16: ;
		nimln(762, "msgs.nim");
		{
			if (!!(((gnotes_166011 &(IL64(1)<<(((((NU16)chckRange(msg, ((NU16) 230), ((NU16) 277)))- 230))&IL64(63))))!=0))) goto LA20;
			goto BeforeRet;
		}
		LA20: ;
		nimln(763, "msgs.nim");
		frmt = copyString(((NimStringDesc*) &TMP1244));
		nimln(764, "msgs.nim");
		TMP1245 = addInt(ghintcounter_166013, ((NI) 1));
		ghintcounter_166013 = (NI)(TMP1245);
	}
	break;
	}
	nimln(765, "msgs.nim");
	LOC22 = 0;
	LOC22 = msgkindtostring_166616(msg);
	LOC23 = 0;
	LOC23 = nsuFormatOpenArray(LOC22, args, argsLen0);
	s = nsuFormatSingleElem(frmt, LOC23);
	nimln(766, "msgs.nim");
	{
		NIM_BOOL LOC26;
		LOC26 = 0;
		LOC26 = ignoremsgbecauseofidetools_166850(msg);
		if (!!(LOC26)) goto LA27;
		nimln(767, "msgs.nim");
		msgwriteln_166536(s);
	}
	LA27: ;
	nimln(768, "msgs.nim");
	handleerror_166647(msg, ((NU8) 1), s);
	}BeforeRet: ;
	popFrame();
}

N_NIMCALL(void, rawmessage_166960)(NU16 msg, NimStringDesc* arg) {
	TY157201 LOC1;
	nimfr("rawMessage", "msgs.nim")
	nimln(771, "msgs.nim");
	memset((void*)LOC1, 0, sizeof(LOC1));
	LOC1[0] = copyString(arg);
	rawmessage_166888(msg, LOC1, 1);
	popFrame();
}

N_NIMCALL(void, writesurroundingsrc_166972)(Tlineinfo165338 info) {
	NimStringDesc* LOC1;
	Ropeobj163009* LOC2;
	NimStringDesc* LOC3;
	NimStringDesc* LOC4;
	NimStringDesc* LOC5;
	nimfr("writeSurroundingSrc", "msgs.nim")
	nimln(775, "msgs.nim");
	LOC1 = 0;
	LOC2 = 0;
	LOC2 = sourceline_165988(info);
	LOC3 = 0;
	LOC3 = HEX24_164131(LOC2);
	LOC1 = rawNewString(LOC3->Sup.len + 2);
appendString(LOC1, ((NimStringDesc*) &TMP1247));
appendString(LOC1, LOC3);
	msgwriteln_166536(LOC1);
	nimln(776, "msgs.nim");
	LOC4 = 0;
	LOC5 = 0;
	LOC5 = nsuRepeatChar(32, ((NI)chckRange(info.col, ((NI) 0), ((NI) IL64(9223372036854775807)))));
	LOC4 = rawNewString(LOC5->Sup.len + 3);
appendString(LOC4, ((NimStringDesc*) &TMP1247));
appendString(LOC4, LOC5);
appendChar(LOC4, 94);
	msgwriteln_166536(LOC4);
	popFrame();
}

N_NIMCALL(NimStringDesc*, formatmsg_166982)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg) {
	NimStringDesc* result;
	NimStringDesc* frmt;
	TY166825 LOC4;
	NI TMP1251;
	nimfr("formatMsg", "msgs.nim")
	result = 0;
	nimln(779, "msgs.nim");
	switch (msg) {
	case ((NU16) 230) ... ((NU16) 260):
	{
		frmt = copyString(((NimStringDesc*) &TMP1248));
	}
	break;
	case ((NU16) 261) ... ((NU16) 277):
	{
		frmt = copyString(((NimStringDesc*) &TMP1249));
	}
	break;
	default:
	{
		frmt = copyString(((NimStringDesc*) &TMP1250));
	}
	break;
	}
	nimln(783, "msgs.nim");
	memset((void*)LOC4, 0, sizeof(LOC4));
	LOC4[0] = tomsgfilename_166429(info);
	LOC4[1] = coordtostr_166606(((NI) (info.line)));
	nimln(784, "msgs.nim");
	TMP1251 = addInt(info.col, ((NI16) 1));
	if (TMP1251 < -32768 || TMP1251 > 32767) raiseOverflow();
	LOC4[2] = coordtostr_166606(((NI) ((NI16)(TMP1251))));
	LOC4[3] = getmessagestr_166626(msg, arg);
	result = nsuFormatOpenArray(frmt, LOC4, 4);
	popFrame();
	return result;
}

static N_INLINE(NIM_BOOL, contains_167086)(Slice167076 s, NU16 value) {
	NIM_BOOL result;
	NIM_BOOL LOC1;
	nimfr("contains", "system.nim")
	result = 0;
	nimln(891, "system.nim");
	LOC1 = 0;
	LOC1 = (s.a <= value);
	if (!(LOC1)) goto LA2;
	LOC1 = (value <= s.b);
	LA2: ;
	result = LOC1;
	popFrame();
	return result;
}

static N_INLINE(Slice167076, HEX2EHEX2E_167067)(NU16 a, NU16 b) {
	Slice167076 result;
	nimfr("..", "system.nim")
	memset((void*)(&result), 0, sizeof(result));
	nimln(234, "system.nim");
	result.a = a;
	nimln(235, "system.nim");
	result.b = b;
	popFrame();
	return result;
}

N_NIMCALL(void, limessage_166997)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg, NU8 eh) {
	NimStringDesc* frmt;
	NIM_BOOL ignoremsg;
	NimStringDesc* s;
	TY166825 LOC12;
	NI TMP1254;
	nimfr("liMessage", "msgs.nim")
	frmt = 0;
	nimln(789, "msgs.nim");
	ignoremsg = NIM_FALSE;
	nimln(790, "msgs.nim");
	switch (msg) {
	case ((NU16) 0) ... ((NU16) 229):
	{
		nimln(792, "msgs.nim");
		writecontext_166800(info);
		nimln(793, "msgs.nim");
		frmt = copyString(((NimStringDesc*) &TMP1250));
		nimln(797, "msgs.nim");
		lasterror_166051 = info;
	}
	break;
	case ((NU16) 230) ... ((NU16) 260):
	{
		NIM_BOOL LOC3;
		NI TMP1252;
		nimln(799, "msgs.nim");
		LOC3 = 0;
		LOC3 = !(((goptions_156126 &(1<<((((NU8) 11))&31)))!=0));
		if (LOC3) goto LA4;
		LOC3 = !(((gnotes_166011 &(IL64(1)<<(((((NU16)chckRange(msg, ((NU16) 230), ((NU16) 277)))- 230))&IL64(63))))!=0));
		LA4: ;
		ignoremsg = LOC3;
		nimln(800, "msgs.nim");
		{
			if (!!(ignoremsg)) goto LA7;
			writecontext_166800(info);
		}
		LA7: ;
		nimln(801, "msgs.nim");
		frmt = copyString(((NimStringDesc*) &TMP1248));
		nimln(802, "msgs.nim");
		TMP1252 = addInt(gwarncounter_166014, ((NI) 1));
		gwarncounter_166014 = (NI)(TMP1252);
	}
	break;
	case ((NU16) 261) ... ((NU16) 277):
	{
		NIM_BOOL LOC10;
		NI TMP1253;
		nimln(804, "msgs.nim");
		LOC10 = 0;
		LOC10 = !(((goptions_156126 &(1<<((((NU8) 12))&31)))!=0));
		if (LOC10) goto LA11;
		LOC10 = !(((gnotes_166011 &(IL64(1)<<(((((NU16)chckRange(msg, ((NU16) 230), ((NU16) 277)))- 230))&IL64(63))))!=0));
		LA11: ;
		ignoremsg = LOC10;
		nimln(805, "msgs.nim");
		frmt = copyString(((NimStringDesc*) &TMP1249));
		nimln(806, "msgs.nim");
		TMP1253 = addInt(ghintcounter_166013, ((NI) 1));
		ghintcounter_166013 = (NI)(TMP1253);
	}
	break;
	}
	nimln(810, "msgs.nim");
	memset((void*)LOC12, 0, sizeof(LOC12));
	LOC12[0] = tomsgfilename_166429(info);
	LOC12[1] = coordtostr_166606(((NI) (info.line)));
	nimln(811, "msgs.nim");
	TMP1254 = addInt(info.col, ((NI16) 1));
	if (TMP1254 < -32768 || TMP1254 > 32767) raiseOverflow();
	LOC12[2] = coordtostr_166606(((NI) ((NI16)(TMP1254))));
	LOC12[3] = getmessagestr_166626(msg, arg);
	s = nsuFormatOpenArray(frmt, LOC12, 4);
	nimln(812, "msgs.nim");
	{
		NIM_BOOL LOC15;
		NIM_BOOL LOC17;
		LOC15 = 0;
		LOC15 = !(ignoremsg);
		if (!(LOC15)) goto LA16;
		LOC17 = 0;
		LOC17 = ignoremsgbecauseofidetools_166850(msg);
		LOC15 = !(LOC17);
		LA16: ;
		if (!LOC15) goto LA18;
		nimln(813, "msgs.nim");
		msgwriteln_166536(s);
		nimln(814, "msgs.nim");
		{
			NIM_BOOL LOC22;
			Slice167076 LOC24;
			LOC22 = 0;
			LOC22 = (((NI) 2) <= gverbosity_156137);
			if (!(LOC22)) goto LA23;
			LOC24 = HEX2EHEX2E_167067(((NU16) 0), ((NU16) 229));
			LOC22 = contains_167086(LOC24, msg);
			LA23: ;
			if (!LOC22) goto LA25;
			nimln(815, "msgs.nim");
			writesurroundingsrc_166972(info);
		}
		LA25: ;
	}
	LA18: ;
	nimln(816, "msgs.nim");
	handleerror_166647(msg, eh, s);
	popFrame();
}

N_NIMCALL(void, fatal_167123)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg) {
	nimfr("fatal", "msgs.nim")
	nimln(819, "msgs.nim");
	limessage_166997(info, msg, arg, ((NU8) 1));
	popFrame();
}

N_NIMCALL(void, globalerror_167134)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg) {
	nimfr("globalError", "msgs.nim")
	nimln(822, "msgs.nim");
	limessage_166997(info, msg, arg, ((NU8) 2));
	popFrame();
}

N_NIMCALL(void, globalerror_167145)(Tlineinfo165338 info, NimStringDesc* arg) {
	nimfr("globalError", "msgs.nim")
	nimln(825, "msgs.nim");
	limessage_166997(info, ((NU16) 4), arg, ((NU8) 2));
	popFrame();
}

N_NIMCALL(void, localerror_167155)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg) {
	nimfr("localError", "msgs.nim")
	nimln(828, "msgs.nim");
	limessage_166997(info, msg, arg, ((NU8) 0));
	popFrame();
}

N_NIMCALL(void, localerror_167166)(Tlineinfo165338 info, NimStringDesc* arg) {
	nimfr("localError", "msgs.nim")
	nimln(831, "msgs.nim");
	limessage_166997(info, ((NU16) 4), arg, ((NU8) 0));
	popFrame();
}

N_NIMCALL(void, localerror_167176)(Tlineinfo165338 info, NimStringDesc* format, NimStringDesc** params, NI paramsLen0) {
	NimStringDesc* LOC1;
	nimfr("localError", "msgs.nim")
	nimln(834, "msgs.nim");
	LOC1 = 0;
	LOC1 = nsuFormatOpenArray(format, params, paramsLen0);
	localerror_167166(info, LOC1);
	popFrame();
}

N_NIMCALL(void, message_167188)(Tlineinfo165338 info, NU16 msg, NimStringDesc* arg) {
	nimfr("message", "msgs.nim")
	nimln(837, "msgs.nim");
	limessage_166997(info, msg, arg, ((NU8) 0));
	popFrame();
}

N_NIMCALL(void, internalerror_167199)(Tlineinfo165338 info, NimStringDesc* errmsg) {
	nimfr("internalError", "msgs.nim")
{	nimln(840, "msgs.nim");
	{
		if (!(gcmd_156130 == ((NU8) 14))) goto LA3;
		goto BeforeRet;
	}
	LA3: ;
	nimln(841, "msgs.nim");
	writecontext_166800(info);
	nimln(842, "msgs.nim");
	limessage_166997(info, ((NU16) 2), errmsg, ((NU8) 1));
	}BeforeRet: ;
	popFrame();
}

N_NIMCALL(void, internalerror_167218)(NimStringDesc* errmsg) {
	Tlineinfo165338 LOC5;
	nimfr("internalError", "msgs.nim")
{	nimln(845, "msgs.nim");
	{
		if (!(gcmd_156130 == ((NU8) 14))) goto LA3;
		goto BeforeRet;
	}
	LA3: ;
	nimln(846, "msgs.nim");
	LOC5 = unknownlineinfo_166024();
	writecontext_166800(LOC5);
	nimln(847, "msgs.nim");
	rawmessage_166960(((NU16) 2), errmsg);
	}BeforeRet: ;
	popFrame();
}

static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src) {
	nimfr("asgnRefNoCycle", "gc.nim")
	nimln(251, "gc.nim");
	{
		Tcell46746* c;
		if (!!((src == NIM_NIL))) goto LA3;
		nimln(252, "gc.nim");
		c = usrtocell_50246(src);
		nimln(169, "gc.nim");
		(*c).refcount += ((NI) 8);
	}
	LA3: ;
	nimln(254, "gc.nim");
	{
		Tcell46746* c;
		if (!!(((*dest) == NIM_NIL))) goto LA7;
		nimln(255, "gc.nim");
		c = usrtocell_50246((*dest));
		nimln(256, "gc.nim");
		{
			nimln(167, "gc.nim");
			(*c).refcount -= ((NI) 8);
			nimln(168, "gc.nim");
			if (!((NU64)((*c).refcount) < (NU64)(((NI) 8)))) goto LA11;
			nimln(257, "gc.nim");
			rtladdzct_51804(c);
		}
		LA11: ;
	}
	LA7: ;
	nimln(258, "gc.nim");
	(*dest) = src;
	popFrame();
}

N_NIMCALL(void, addsourceline_167254)(NI32 fileidx, NimStringDesc* line) {
	Ropeobj163009* LOC1;
	nimfr("addSourceLine", "msgs.nim")
	nimln(857, "msgs.nim");
	if ((NU)(fileidx) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
	LOC1 = 0;
	LOC1 = rope_163320(line);
	fileinfos_165432->data[fileidx].lines = (TY163599*) incrSeq(&(fileinfos_165432->data[fileidx].lines)->Sup, sizeof(Ropeobj163009*));
	asgnRefNoCycle((void**) (&fileinfos_165432->data[fileidx].lines->data[fileinfos_165432->data[fileidx].lines->Sup.len-1]), LOC1);
	popFrame();
}

static N_INLINE(Exception*, getCurrentException)(void) {
	Exception* result;
	nimfr("getCurrentException", "system.nim")
	result = 0;
	nimln(2726, "system.nim");
	result = currexception_17045;
	popFrame();
	return result;
}

N_NIMCALL(Ropeobj163009*, sourceline_165988)(Tlineinfo165338 i) {
	Ropeobj163009* result;
	NI TMP1262;
	nimfr("sourceLine", "msgs.nim")
{	result = 0;
	nimln(860, "msgs.nim");
	{
		if (!(i.fileindex < ((NI32) 0))) goto LA3;
		result = NIM_NIL;
		goto BeforeRet;
	}
	LA3: ;
	nimln(862, "msgs.nim");
	{
		NIM_BOOL LOC7;
		TSafePoint TMP1259;
		LOC7 = 0;
		LOC7 = !(((gglobaloptions_156128 &(1<<((((NU8) 27))&31)))!=0));
		if (!(LOC7)) goto LA8;
		if ((NU)(i.fileindex) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
		LOC7 = ((fileinfos_165432->data[i.fileindex].lines ? fileinfos_165432->data[i.fileindex].lines->Sup.len : 0) == ((NI) 0));
		LA8: ;
		if (!LOC7) goto LA9;
		nimln(863, "msgs.nim");
		pushSafePoint(&TMP1259);
		TMP1259.status = setjmp(TMP1259.context);
		if (TMP1259.status == 0) {
			{
				NimStringDesc* line_167296;
				NimStringDesc* HEX3Atmp_167332;
				FILE* f_167335;
				NimStringDesc* res_167337;
				line_167296 = 0;
				HEX3Atmp_167332 = 0;
				nimln(864, "msgs.nim");
				HEX3Atmp_167332 = tofullpath_166273(i.fileindex);
				nimln(2699, "system.nim");
				f_167335 = open_13217(HEX3Atmp_167332, ((NU8) 0), ((NI) 8000));
				nimln(2700, "system.nim");
				res_167337 = rawNewString(((NI) 80));
				{
					nimln(2701, "system.nim");
					while (1) {
						NIM_BOOL LOC15;
						LOC15 = 0;
						LOC15 = readline_13481(f_167335, (&res_167337));
						if (!LOC15) goto LA14;
						nimln(2700, "system.nim");
						line_167296 = res_167337;
						nimln(865, "msgs.nim");
						addsourceline_167254(i.fileindex, line_167296);
					} LA14: ;
				}
				nimln(2702, "system.nim");
				fclose(f_167335);
			}
			popSafePoint();
		}
		else {
			popSafePoint();
			setFrame((TFrame*)&FR);
			if (isObj(getCurrentException()->Sup.m_type, (&NTI3431))) {
				TMP1259.status = 0;
				popCurrentException();
			}
		}
		if (TMP1259.status != 0) reraiseException();
	}
	LA9: ;
	nimln(854, "msgs.nim");
	{
		NimStringDesc* LOC22;
		nimln(868, "msgs.nim");
		if (!!((((NI) (i.fileindex)) < (fileinfos_165432 ? fileinfos_165432->Sup.len : 0)))) goto LA20;
		nimln(854, "msgs.nim");
		LOC22 = 0;
		LOC22 = HEX24_167306(TMP1260);
		internalerror_167218(LOC22);
	}
	LA20: ;
	nimln(870, "msgs.nim");
	{
		if ((NU)(i.fileindex) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
		if (!((fileinfos_165432->data[i.fileindex].lines ? fileinfos_165432->data[i.fileindex].lines->Sup.len : 0) < ((NI) (i.line)))) goto LA25;
		result = NIM_NIL;
		goto BeforeRet;
	}
	LA25: ;
	nimln(872, "msgs.nim");
	if ((NU)(i.fileindex) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
	TMP1262 = subInt(i.line, ((NI16) 1));
	if (TMP1262 < -32768 || TMP1262 > 32767) raiseOverflow();
	if ((NU)((NI16)(TMP1262)) >= (NU)(fileinfos_165432->data[i.fileindex].lines->Sup.len)) raiseIndexError();
	result = fileinfos_165432->data[i.fileindex].lines->data[(NI16)(TMP1262)];
	}BeforeRet: ;
	popFrame();
	return result;
}

N_NIMCALL(Ropeobj163009*, quotedfilename_167354)(Tlineinfo165338 i) {
	Ropeobj163009* result;
	nimfr("quotedFilename", "msgs.nim")
	result = 0;
	nimln(854, "msgs.nim");
	{
		NimStringDesc* LOC5;
		nimln(875, "msgs.nim");
		if (!!((((NI32) 0) <= i.fileindex))) goto LA3;
		nimln(854, "msgs.nim");
		LOC5 = 0;
		LOC5 = HEX24_167306(TMP1263);
		internalerror_167218(LOC5);
	}
	LA3: ;
	nimln(876, "msgs.nim");
	if ((NU)(i.fileindex) >= (NU)(fileinfos_165432->Sup.len)) raiseIndexError();
	result = fileinfos_165432->data[i.fileindex].quotedname;
	popFrame();
	return result;
}

N_NIMCALL(void, HEX3Aanonymous_167371)(NU8 err, NimStringDesc* msg, NIM_BOOL usewarning) {
	nimfr(":anonymous", "msgs.nim")
	nimln(879, "msgs.nim");
	switch (err) {
	case ((NU8) 1):
	{
		NimStringDesc* LOC2;
		nimln(881, "msgs.nim");
		LOC2 = 0;
		LOC2 = rawNewString(msg->Sup.len + 30);
appendString(LOC2, ((NimStringDesc*) &TMP1264));
appendString(LOC2, msg);
		internalerror_167218(LOC2);
	}
	break;
	case ((NU8) 0):
	{
		NU16 LOC4;
		nimln(883, "msgs.nim");
		LOC4 = 0;
		{
			if (!usewarning) goto LA7;
			LOC4 = ((NU16) 230);
		}
		goto LA5;
		LA7: ;
		{
			LOC4 = ((NU16) 3);
		}
		LA5: ;
		rawmessage_166960(LOC4, msg);
	}
	break;
	}
	popFrame();
}
NIM_EXTERNC N_NOINLINE(void, compiler_msgsInit)(void) {
	Tfileinfo165336 LOC1;
	Tfileinfo165336 LOC2;
	TY163023 LOC3;
	nimfr("msgs", "msgs.nim")
	nimln(486, "msgs.nim");
	chckNil((void*)(&filenametoindextbl_165414));
	genericReset((void*)(&filenametoindextbl_165414), (&NTI165376));
	inittable_165368(((NI) 64), (&filenametoindextbl_165414));
	nimln(487, "msgs.nim");
	if (fileinfos_165432) nimGCunrefNoCycle(fileinfos_165432);
	fileinfos_165432 = (TY165415*) newSeqRC1((&NTI165415), 0);
	nimln(558, "msgs.nim");
	memset((void*)(&LOC1), 0, sizeof(LOC1));
	newfileinfo_165495(((NimStringDesc*) &TMP1177), ((NimStringDesc*) &TMP1189), (&LOC1));
	fileinfos_165432 = (TY165415*) incrSeq(&(fileinfos_165432)->Sup, sizeof(Tfileinfo165336));
	genericAssign((void*)(&fileinfos_165432->data[fileinfos_165432->Sup.len-1]), (void*)(&LOC1), (&NTI165336));
	nimln(559, "msgs.nim");
	gcmdlineinfo_165921 = newlineinfo_165866(((NI32) 0), ((NI) 1), ((NI) 1));
	nimln(561, "msgs.nim");
	memset((void*)(&LOC2), 0, sizeof(LOC2));
	newfileinfo_165495(((NimStringDesc*) &TMP1177), ((NimStringDesc*) &TMP1190), (&LOC2));
	fileinfos_165432 = (TY165415*) incrSeq(&(fileinfos_165432)->Sup, sizeof(Tfileinfo165336));
	genericAssign((void*)(&fileinfos_165432->data[fileinfos_165432->Sup.len-1]), (void*)(&LOC2), (&NTI165336));
	nimln(562, "msgs.nim");
	gcodegenlineinfo_165959 = newlineinfo_165866(((NI32) 1), ((NI) 1), ((NI) 1));
	nimln(570, "msgs.nim");
	gnotes_166011 = IL64(281474927951871);
	nimln(573, "msgs.nim");
	gerrorcounter_166012 = ((NI) 0);
	nimln(574, "msgs.nim");
	ghintcounter_166013 = ((NI) 0);
	nimln(575, "msgs.nim");
	gwarncounter_166014 = ((NI) 0);
	nimln(576, "msgs.nim");
	gerrormax_166015 = ((NI) 1);
	nimln(584, "msgs.nim");
	if (msgcontext_166050) nimGCunrefNoCycle(msgcontext_166050);
	msgcontext_166050 = (TY166033*) newSeqRC1((&NTI166033), 0);
	nimln(585, "msgs.nim");
	lasterror_166051 = unknownlineinfo_166024();
	nimln(587, "msgs.nim");
	erroroutputs_166053 = 3;
	nimln(878, "msgs.nim");
	memset((void*)(&LOC3), 0, sizeof(LOC3));
	LOC3.ClPrc = ((TMP1265) (HEX3Aanonymous_167371)); LOC3.ClEnv = NIM_NIL;
	asgnRef((void**) (&errorhandler_163028.ClEnv), LOC3.ClEnv);
	errorhandler_163028.ClPrc = LOC3.ClPrc;
	popFrame();
}

NIM_EXTERNC N_NOINLINE(void, compiler_msgsDatInit)(void) {
static TNimNode* TMP1165[6];
static TNimNode* TMP1192[3];
static TNimNode* TMP4178[278];
NI TMP4180;
static char* NIM_CONST TMP4179[278] = {
"errUnknown", 
"errIllFormedAstX", 
"errInternal", 
"errCannotOpenFile", 
"errGenerated", 
"errXCompilerDoesNotSupportCpp", 
"errStringLiteralExpected", 
"errIntLiteralExpected", 
"errInvalidCharacterConstant", 
"errClosingTripleQuoteExpected", 
"errClosingQuoteExpected", 
"errTabulatorsAreNotAllowed", 
"errInvalidToken", 
"errLineTooLong", 
"errInvalidNumber", 
"errNumberOutOfRange", 
"errNnotAllowedInCharacter", 
"errClosingBracketExpected", 
"errMissingFinalQuote", 
"errIdentifierExpected", 
"errNewlineExpected", 
"errInvalidModuleName", 
"errOperatorExpected", 
"errTokenExpected", 
"errStringAfterIncludeExpected", 
"errRecursiveDependencyX", 
"errOnOrOffExpected", 
"errNoneSpeedOrSizeExpected", 
"errInvalidPragma", 
"errUnknownPragma", 
"errInvalidDirectiveX", 
"errAtPopWithoutPush", 
"errEmptyAsm", 
"errInvalidIndentation", 
"errExceptionExpected", 
"errExceptionAlreadyHandled", 
"errYieldNotAllowedHere", 
"errYieldNotAllowedInTryStmt", 
"errInvalidNumberOfYieldExpr", 
"errCannotReturnExpr", 
"errAttemptToRedefine", 
"errStmtInvalidAfterReturn", 
"errStmtExpected", 
"errInvalidLabel", 
"errInvalidCmdLineOption", 
"errCmdLineArgExpected", 
"errCmdLineNoArgExpected", 
"errInvalidVarSubstitution", 
"errUnknownVar", 
"errUnknownCcompiler", 
"errOnOrOffExpectedButXFound", 
"errNoneBoehmRefcExpectedButXFound", 
"errNoneSpeedOrSizeExpectedButXFound", 
"errGuiConsoleOrLibExpectedButXFound", 
"errUnknownOS", 
"errUnknownCPU", 
"errGenOutExpectedButXFound", 
"errArgsNeedRunOption", 
"errInvalidMultipleAsgn", 
"errColonOrEqualsExpected", 
"errExprExpected", 
"errUndeclaredIdentifier", 
"errUseQualifier", 
"errTypeExpected", 
"errSystemNeeds", 
"errExecutionOfProgramFailed", 
"errNotOverloadable", 
"errInvalidArgForX", 
"errStmtHasNoEffect", 
"errXExpectsTypeOrValue", 
"errXExpectsArrayType", 
"errIteratorCannotBeInstantiated", 
"errExprXAmbiguous", 
"errConstantDivisionByZero", 
"errOrdinalTypeExpected", 
"errOrdinalOrFloatTypeExpected", 
"errOverOrUnderflow", 
"errCannotEvalXBecauseIncompletelyDefined", 
"errChrExpectsRange0_255", 
"errDynlibRequiresExportc", 
"errUndeclaredFieldX", 
"errNilAccess", 
"errIndexOutOfBounds", 
"errIndexTypesDoNotMatch", 
"errBracketsInvalidForType", 
"errValueOutOfSetBounds", 
"errFieldInitTwice", 
"errFieldNotInit", 
"errExprXCannotBeCalled", 
"errExprHasNoType", 
"errExprXHasNoType", 
"errCastNotInSafeMode", 
"errExprCannotBeCastedToX", 
"errCommaOrParRiExpected", 
"errCurlyLeOrParLeExpected", 
"errSectionExpected", 
"errRangeExpected", 
"errMagicOnlyInSystem", 
"errPowerOfTwoExpected", 
"errStringMayNotBeEmpty", 
"errCallConvExpected", 
"errProcOnlyOneCallConv", 
"errSymbolMustBeImported", 
"errExprMustBeBool", 
"errConstExprExpected", 
"errDuplicateCaseLabel", 
"errRangeIsEmpty", 
"errSelectorMustBeOfCertainTypes", 
"errSelectorMustBeOrdinal", 
"errOrdXMustNotBeNegative", 
"errLenXinvalid", 
"errWrongNumberOfVariables", 
"errExprCannotBeRaised", 
"errBreakOnlyInLoop", 
"errTypeXhasUnknownSize", 
"errConstNeedsConstExpr", 
"errConstNeedsValue", 
"errResultCannotBeOpenArray", 
"errSizeTooBig", 
"errSetTooBig", 
"errBaseTypeMustBeOrdinal", 
"errInheritanceOnlyWithNonFinalObjects", 
"errInheritanceOnlyWithEnums", 
"errIllegalRecursionInTypeX", 
"errCannotInstantiateX", 
"errExprHasNoAddress", 
"errXStackEscape", 
"errVarForOutParamNeeded", 
"errPureTypeMismatch", 
"errTypeMismatch", 
"errButExpected", 
"errButExpectedX", 
"errAmbiguousCallXYZ", 
"errWrongNumberOfArguments", 
"errXCannotBePassedToProcVar", 
"errXCannotBeInParamDecl", 
"errPragmaOnlyInHeaderOfProc", 
"errImplOfXNotAllowed", 
"errImplOfXexpected", 
"errNoSymbolToBorrowFromFound", 
"errDiscardValueX", 
"errInvalidDiscard", 
"errIllegalConvFromXtoY", 
"errCannotBindXTwice", 
"errInvalidOrderInArrayConstructor", 
"errInvalidOrderInEnumX", 
"errEnumXHasHoles", 
"errExceptExpected", 
"errInvalidTry", 
"errOptionExpected", 
"errXisNoLabel", 
"errNotAllCasesCovered", 
"errUnknownSubstitionVar", 
"errComplexStmtRequiresInd", 
"errXisNotCallable", 
"errNoPragmasAllowedForX", 
"errNoGenericParamsAllowedForX", 
"errInvalidParamKindX", 
"errDefaultArgumentInvalid", 
"errNamedParamHasToBeIdent", 
"errNoReturnTypeForX", 
"errConvNeedsOneArg", 
"errInvalidPragmaX", 
"errXNotAllowedHere", 
"errInvalidControlFlowX", 
"errXisNoType", 
"errCircumNeedsPointer", 
"errInvalidExpression", 
"errInvalidExpressionX", 
"errEnumHasNoValueX", 
"errNamedExprExpected", 
"errNamedExprNotAllowed", 
"errXExpectsOneTypeParam", 
"errArrayExpectsTwoTypeParams", 
"errInvalidVisibilityX", 
"errInitHereNotAllowed", 
"errXCannotBeAssignedTo", 
"errIteratorNotAllowed", 
"errXNeedsReturnType", 
"errNoReturnTypeDeclared", 
"errInvalidCommandX", 
"errXOnlyAtModuleScope", 
"errXNeedsParamObjectType", 
"errTemplateInstantiationTooNested", 
"errInstantiationFrom", 
"errInvalidIndexValueForTuple", 
"errCommandExpectsFilename", 
"errMainModuleMustBeSpecified", 
"errXExpected", 
"errTIsNotAConcreteType", 
"errInvalidSectionStart", 
"errGridTableNotImplemented", 
"errGeneralParseError", 
"errNewSectionExpected", 
"errWhitespaceExpected", 
"errXisNoValidIndexFile", 
"errCannotRenderX", 
"errVarVarTypeNotAllowed", 
"errInstantiateXExplicitly", 
"errOnlyACallOpCanBeDelegator", 
"errUsingNoSymbol", 
"errMacroBodyDependsOnGenericTypes", 
"errDestructorNotGenericEnough", 
"errInlineIteratorsAsProcParams", 
"errXExpectsTwoArguments", 
"errXExpectsObjectTypes", 
"errXcanNeverBeOfThisSubtype", 
"errTooManyIterations", 
"errCannotInterpretNodeX", 
"errFieldXNotFound", 
"errInvalidConversionFromTypeX", 
"errAssertionFailed", 
"errCannotGenerateCodeForX", 
"errXRequiresOneArgument", 
"errUnhandledExceptionX", 
"errCyclicTree", 
"errXisNoMacroOrTemplate", 
"errXhasSideEffects", 
"errIteratorExpected", 
"errLetNeedsInit", 
"errThreadvarCannotInit", 
"errWrongSymbolX", 
"errIllegalCaptureX", 
"errXCannotBeClosure", 
"errXMustBeCompileTime", 
"errCannotInferTypeOfTheLiteral", 
"errCannotInferReturnType", 
"errGenericLambdaNotAllowed", 
"errCompilerDoesntSupportTarget", 
"errUser", 
"warnCannotOpenFile", 
"warnOctalEscape", 
"warnXIsNeverRead", 
"warnXmightNotBeenInit", 
"warnDeprecated", 
"warnConfigDeprecated", 
"warnSmallLshouldNotBeUsed", 
"warnUnknownMagic", 
"warnRedefinitionOfLabel", 
"warnUnknownSubstitutionX", 
"warnLanguageXNotSupported", 
"warnFieldXNotSupported", 
"warnCommentXIgnored", 
"warnNilStatement", 
"warnTypelessParam", 
"warnDifferentHeaps", 
"warnWriteToForeignHeap", 
"warnUnsafeCode", 
"warnEachIdentIsTuple", 
"warnShadowIdent", 
"warnProveInit", 
"warnProveField", 
"warnProveIndex", 
"warnGcUnsafe", 
"warnGcUnsafe2", 
"warnUninit", 
"warnGcMem", 
"warnDestructor", 
"warnLockLevel", 
"warnResultShadowed", 
"warnUser", 
"hintSuccess", 
"hintSuccessX", 
"hintLineTooLong", 
"hintXDeclaredButNotUsed", 
"hintConvToBaseNotNeeded", 
"hintConvFromXtoItselfNotNeeded", 
"hintExprAlwaysX", 
"hintQuitCalled", 
"hintProcessing", 
"hintCodeBegin", 
"hintCodeEnd", 
"hintConf", 
"hintPath", 
"hintConditionAlwaysTrue", 
"hintName", 
"hintPattern", 
"hintUser"};
static TNimNode TMP468[293];
NTI165336.size = sizeof(Tfileinfo165336);
NTI165336.kind = 18;
NTI165336.base = 0;
NTI165336.flags = 2;
TMP1165[0] = &TMP468[1];
TMP468[1].kind = 1;
TMP468[1].offset = offsetof(Tfileinfo165336, fullpath);
TMP468[1].typ = (&NTI149);
TMP468[1].name = "fullPath";
TMP1165[1] = &TMP468[2];
TMP468[2].kind = 1;
TMP468[2].offset = offsetof(Tfileinfo165336, projpath);
TMP468[2].typ = (&NTI149);
TMP468[2].name = "projPath";
TMP1165[2] = &TMP468[3];
TMP468[3].kind = 1;
TMP468[3].offset = offsetof(Tfileinfo165336, shortname);
TMP468[3].typ = (&NTI149);
TMP468[3].name = "shortName";
TMP1165[3] = &TMP468[4];
TMP468[4].kind = 1;
TMP468[4].offset = offsetof(Tfileinfo165336, quotedname);
TMP468[4].typ = (&NTI163007);
TMP468[4].name = "quotedName";
TMP1165[4] = &TMP468[5];
TMP468[5].kind = 1;
TMP468[5].offset = offsetof(Tfileinfo165336, lines);
TMP468[5].typ = (&NTI163599);
TMP468[5].name = "lines";
TMP1165[5] = &TMP468[6];
TMP468[6].kind = 1;
TMP468[6].offset = offsetof(Tfileinfo165336, dirtyfile);
TMP468[6].typ = (&NTI149);
TMP468[6].name = "dirtyfile";
TMP468[0].len = 6; TMP468[0].kind = 2; TMP468[0].sons = &TMP1165[0];
NTI165336.node = &TMP468[0];
NTI165415.size = sizeof(TY165415*);
NTI165415.kind = 24;
NTI165415.base = (&NTI165336);
NTI165415.flags = 2;
NTI165415.marker = TMP1166;
NTI165344.size = sizeof(Erecoverableerror165344);
NTI165344.kind = 17;
NTI165344.base = (&NTI3449);
TMP468[7].len = 0; TMP468[7].kind = 2;
NTI165344.node = &TMP468[7];
NTI165972.size = sizeof(Erecoverableerror165344*);
NTI165972.kind = 22;
NTI165972.base = (&NTI165344);
NTI165972.marker = TMP1191;
NTI165338.size = sizeof(Tlineinfo165338);
NTI165338.kind = 18;
NTI165338.base = 0;
NTI165338.flags = 3;
TMP1192[0] = &TMP468[9];
TMP468[9].kind = 1;
TMP468[9].offset = offsetof(Tlineinfo165338, line);
TMP468[9].typ = (&NTI112);
TMP468[9].name = "line";
TMP1192[1] = &TMP468[10];
TMP468[10].kind = 1;
TMP468[10].offset = offsetof(Tlineinfo165338, col);
TMP468[10].typ = (&NTI112);
TMP468[10].name = "col";
TMP1192[2] = &TMP468[11];
TMP468[11].kind = 1;
TMP468[11].offset = offsetof(Tlineinfo165338, fileindex);
TMP468[11].typ = (&NTI114);
TMP468[11].name = "fileIndex";
TMP468[8].len = 3; TMP468[8].kind = 2; TMP468[8].sons = &TMP1192[0];
NTI165338.node = &TMP468[8];
NTI166033.size = sizeof(TY166033*);
NTI166033.kind = 24;
NTI166033.base = (&NTI165338);
NTI166033.flags = 2;
NTI166033.marker = TMP1193;
NTI165346.size = sizeof(Esuggestdone165346);
NTI165346.kind = 17;
NTI165346.base = (&NTI3427);
TMP468[12].len = 0; TMP468[12].kind = 2;
NTI165346.node = &TMP468[12];
NTI166127.size = sizeof(Esuggestdone165346*);
NTI166127.kind = 22;
NTI166127.base = (&NTI165346);
NTI166127.marker = TMP1196;
NTI165005.size = sizeof(NU16);
NTI165005.kind = 14;
NTI165005.base = 0;
NTI165005.flags = 3;
for (TMP4180 = 0; TMP4180 < 278; TMP4180++) {
TMP468[TMP4180+13].kind = 1;
TMP468[TMP4180+13].offset = TMP4180;
TMP468[TMP4180+13].name = TMP4179[TMP4180];
TMP4178[TMP4180] = &TMP468[TMP4180+13];
}
TMP468[291].len = 278; TMP468[291].kind = 2; TMP468[291].sons = &TMP4178[0];
NTI165005.node = &TMP468[291];
NTI165332.size = sizeof(NU16);
NTI165332.kind = 20;
NTI165332.base = (&NTI165005);
NTI165332.flags = 3;
NTI165334.size = sizeof(NU64);
NTI165334.kind = 19;
NTI165334.base = (&NTI165332);
NTI165334.flags = 3;
TMP468[292].len = 230; TMP468[292].kind = 0;
NTI165334.node = &TMP468[292];
}

